{
  "slug": "go",
  "meta": {
    "title": "Go 言語基礎",
    "description": "Go 言語のコア機能、並行プログラミングとクラウドネイティブ開発",
    "order": 1,
    "tags": [
      "go",
      "golang",
      "compiled",
      "concurrency"
    ]
  },
  "content": "<h1>Go 言語基礎</h1>\n<h2>Go 言語概要</h2>\n<p>Go (Golang) は Google が開発した静的型付け、コンパイル型言語で、シンプルさ、効率性、強力な並行処理サポートで知られ、クラウドネイティブ開発の第一選択肢です。</p>\n<pre><code>Go の特徴\n├── コンパイル型 - 直接マシンコードにコンパイル\n├── 静的型付け - コンパイル時の型チェック\n├── ガベージコレクション - 自動メモリ管理\n├── ネイティブ並行処理 - goroutine + channel\n└── クロスコンパイル - 簡単にクロスプラットフォーム\n</code></pre>\n<h2>基本構文</h2>\n<h3>変数と型</h3>\n<pre><code class=\"language-go\">package main\n\nimport \"fmt\"\n\nfunc main() {\n    // 変数宣言\n    var name string = \"Go\"\n    var age int = 15\n    var isCompiled bool = true\n\n    // 短い変数宣言 (型推論)\n    version := \"1.21\"\n    count := 100\n\n    // 複数変数宣言\n    var x, y, z int = 1, 2, 3\n    a, b := \"hello\", \"world\"\n\n    // 定数\n    const Pi = 3.14159\n    const (\n        StatusOK = 200\n        StatusNotFound = 404\n    )\n\n    fmt.Println(name, version)\n}\n</code></pre>\n<h3>複合型</h3>\n<pre><code class=\"language-go\">// 配列 - 固定長\nvar arr [5]int = [5]int{1, 2, 3, 4, 5}\n\n// スライス - 動的配列\nslice := []int{1, 2, 3}\nslice = append(slice, 4, 5)\n\n// make でスライス作成\ns := make([]int, 5, 10)  // len=5, cap=10\n\n// Map\nm := map[string]int{\n    \"apple\":  1,\n    \"banana\": 2,\n}\n\nvalue, exists := m[\"apple\"]\nif exists {\n    fmt.Println(value)\n}\n\n// 構造体\ntype Person struct {\n    Name string\n    Age  int\n    City string `json:\"city\"`\n}\n\np := Person{Name: \"Alice\", Age: 30}\n</code></pre>\n<h3>制御フロー</h3>\n<pre><code class=\"language-go\">// if-else\nif x > 0 {\n    fmt.Println(\"positive\")\n} else if x &#x3C; 0 {\n    fmt.Println(\"negative\")\n} else {\n    fmt.Println(\"zero\")\n}\n\n// switch\nswitch day {\ncase \"Monday\", \"Tuesday\":\n    fmt.Println(\"weekday\")\ncase \"Saturday\", \"Sunday\":\n    fmt.Println(\"weekend\")\ndefault:\n    fmt.Println(\"unknown\")\n}\n\n// for ループ (Go は for のみ)\nfor i := 0; i &#x3C; 10; i++ {\n    fmt.Println(i)\n}\n\n// range で反復\nfor i, v := range slice {\n    fmt.Printf(\"index: %d, value: %d\\n\", i, v)\n}\n</code></pre>\n<h3>関数</h3>\n<pre><code class=\"language-go\">// 基本関数\nfunc add(a, b int) int {\n    return a + b\n}\n\n// 複数戻り値\nfunc divide(a, b float64) (float64, error) {\n    if b == 0 {\n        return 0, errors.New(\"division by zero\")\n    }\n    return a / b, nil\n}\n\n// 可変長引数\nfunc sum(nums ...int) int {\n    total := 0\n    for _, n := range nums {\n        total += n\n    }\n    return total\n}\n\n// defer - 遅延実行\nfunc readFile(path string) error {\n    f, err := os.Open(path)\n    if err != nil {\n        return err\n    }\n    defer f.Close()\n    return nil\n}\n</code></pre>\n<h3>メソッドとインターフェース</h3>\n<pre><code class=\"language-go\">// メソッド\ntype Rectangle struct {\n    Width, Height float64\n}\n\nfunc (r Rectangle) Area() float64 {\n    return r.Width * r.Height\n}\n\nfunc (r *Rectangle) Scale(factor float64) {\n    r.Width *= factor\n    r.Height *= factor\n}\n\n// インターフェース\ntype Shape interface {\n    Area() float64\n    Perimeter() float64\n}\n\n// Circle は自動的に Shape を実装\ntype Circle struct {\n    Radius float64\n}\n\nfunc (c Circle) Area() float64 {\n    return math.Pi * c.Radius * c.Radius\n}\n\nfunc (c Circle) Perimeter() float64 {\n    return 2 * math.Pi * c.Radius\n}\n</code></pre>\n<h2>並行プログラミング</h2>\n<h3>Goroutine</h3>\n<pre><code class=\"language-go\">// goroutine の起動\ngo func() {\n    fmt.Println(\"Hello from goroutine\")\n}()\n\n// 完了を待つ\nvar wg sync.WaitGroup\n\nfor i := 0; i &#x3C; 5; i++ {\n    wg.Add(1)\n    go func(n int) {\n        defer wg.Done()\n        fmt.Println(n)\n    }(i)\n}\n\nwg.Wait()\n</code></pre>\n<h3>Channel</h3>\n<pre><code class=\"language-go\">// channel の作成\nch := make(chan int)        // バッファなし\nch := make(chan int, 10)    // バッファあり\n\n// 送受信\nch &#x3C;- 42        // 送信\nvalue := &#x3C;-ch   // 受信\n\n// channel を閉じる\nclose(ch)\n\n// channel の反復\nfor v := range ch {\n    fmt.Println(v)\n}\n\n// select 多重化\nselect {\ncase msg := &#x3C;-ch1:\n    fmt.Println(\"from ch1:\", msg)\ncase msg := &#x3C;-ch2:\n    fmt.Println(\"from ch2:\", msg)\ncase &#x3C;-time.After(time.Second):\n    fmt.Println(\"timeout\")\n}\n</code></pre>\n<h3>並行パターン</h3>\n<pre><code class=\"language-go\">// Worker Pool\nfunc worker(id int, jobs &#x3C;-chan int, results chan&#x3C;- int) {\n    for j := range jobs {\n        results &#x3C;- j * 2\n    }\n}\n\n// Context による制御\nfunc longRunningTask(ctx context.Context) error {\n    for {\n        select {\n        case &#x3C;-ctx.Done():\n            return ctx.Err()\n        default:\n            // タスク実行\n        }\n    }\n}\n\nctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\ndefer cancel()\n</code></pre>\n<h2>エラー処理</h2>\n<pre><code class=\"language-go\">// エラーを返す\nfunc readConfig(path string) (*Config, error) {\n    data, err := os.ReadFile(path)\n    if err != nil {\n        return nil, fmt.Errorf(\"failed to read config: %w\", err)\n    }\n    return &#x26;cfg, nil\n}\n\n// カスタムエラー\ntype ValidationError struct {\n    Field   string\n    Message string\n}\n\nfunc (e *ValidationError) Error() string {\n    return fmt.Sprintf(\"%s: %s\", e.Field, e.Message)\n}\n\n// エラーチェック\nif errors.Is(err, os.ErrNotExist) {\n    // ファイルが存在しない\n}\n</code></pre>\n<h2>ジェネリクス (Go 1.18+)</h2>\n<pre><code class=\"language-go\">// ジェネリック関数\nfunc Min[T constraints.Ordered](a, b T) T {\n    if a &#x3C; b {\n        return a\n    }\n    return b\n}\n\n// ジェネリック型\ntype Stack[T any] struct {\n    items []T\n}\n\nfunc (s *Stack[T]) Push(item T) {\n    s.items = append(s.items, item)\n}\n\nfunc (s *Stack[T]) Pop() (T, bool) {\n    if len(s.items) == 0 {\n        var zero T\n        return zero, false\n    }\n    item := s.items[len(s.items)-1]\n    s.items = s.items[:len(s.items)-1]\n    return item, true\n}\n</code></pre>\n<h2>よく使う標準ライブラリ</h2>\n<pre><code class=\"language-go\">// fmt - フォーマット I/O\nfmt.Printf(\"Name: %s, Age: %d\\n\", name, age)\n\n// strings\nstrings.Contains(\"hello\", \"ell\")\nstrings.Split(\"a,b,c\", \",\")\n\n// time\nnow := time.Now()\nt.Format(\"2006-01-02 15:04:05\")\n\n// encoding/json\ndata, _ := json.Marshal(obj)\njson.Unmarshal(data, &#x26;obj)\n\n// net/http\nhttp.HandleFunc(\"/\", handler)\nhttp.ListenAndServe(\":8080\", nil)\n</code></pre>\n<h2>まとめ</h2>\n<p>Go 言語のポイント：</p>\n<ol>\n<li><strong>シンプルな設計</strong> - 構文がシンプルで学習曲線が緩やか</li>\n<li><strong>ネイティブ並行処理</strong> - goroutine 軽量スレッド</li>\n<li><strong>高速コンパイル</strong> - コンパイル速度が非常に速い</li>\n<li><strong>静的リンク</strong> - 単一バイナリでデプロイ</li>\n<li><strong>クラウドネイティブ第一選択</strong> - Docker, K8s は Go で書かれている</li>\n</ol>\n"
}