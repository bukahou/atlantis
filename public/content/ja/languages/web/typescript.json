{
  "slug": "typescript",
  "meta": {
    "title": "TypeScript 言語基礎",
    "description": "TypeScript 型システム、高度な型とフロントエンド開発のベストプラクティス",
    "order": 1,
    "tags": [
      "typescript",
      "web",
      "frontend",
      "static-typing"
    ]
  },
  "content": "<h1>TypeScript 言語基礎</h1>\n<h2>TypeScript 概要</h2>\n<p>TypeScript は JavaScript のスーパーセットで、静的型システムとモダンな ECMAScript 機能を追加し、より良い開発体験とコードの保守性を提供します。</p>\n<pre><code>TypeScript の特徴\n├── 静的型付け - コンパイル時の型チェック\n├── 型推論 - スマートな型推定\n├── 段階的導入 - JavaScript との完全互換\n├── モダン構文 - 最新 ECMAScript 機能をサポート\n└── ツールサポート - 強力な IDE サポート\n</code></pre>\n<h2>基本型</h2>\n<h3>プリミティブ型</h3>\n<pre><code class=\"language-typescript\">// 基本型\nlet name: string = \"TypeScript\";\nlet age: number = 10;\nlet isTyped: boolean = true;\nlet nothing: null = null;\nlet notDefined: undefined = undefined;\n\n// 型推論\nlet inferred = \"Hello\";  // 自動的に string と推論\n\n// リテラル型\nlet direction: \"left\" | \"right\" | \"up\" | \"down\" = \"left\";\nlet statusCode: 200 | 404 | 500 = 200;\n\n// any と unknown\nlet anyValue: any = \"anything\";\nlet unknownValue: unknown = \"check first\";\n\n// unknown は型チェックが必要\nif (typeof unknownValue === \"string\") {\n    console.log(unknownValue.toUpperCase());\n}\n\n// never - 決して返らない\nfunction throwError(msg: string): never {\n    throw new Error(msg);\n}\n</code></pre>\n<h3>配列とタプル</h3>\n<pre><code class=\"language-typescript\">// 配列\nlet numbers: number[] = [1, 2, 3];\nlet strings: Array&#x3C;string> = [\"a\", \"b\", \"c\"];\n\n// 読み取り専用配列\nlet readonlyArr: readonly number[] = [1, 2, 3];\nlet readonlyArr2: ReadonlyArray&#x3C;number> = [1, 2, 3];\n\n// タプル - 固定長と型\nlet tuple: [string, number] = [\"age\", 30];\nlet tuple2: [string, number, boolean] = [\"name\", 1, true];\n\n// ラベル付きタプル (TS 4.0+)\ntype Point = [x: number, y: number, z?: number];\nlet point: Point = [10, 20];\n\n// 可変長タプル\ntype StringNumberBooleans = [string, number, ...boolean[]];\n</code></pre>\n<h3>オブジェクト型</h3>\n<pre><code class=\"language-typescript\">// オブジェクト型\nlet user: { name: string; age: number } = {\n    name: \"Alice\",\n    age: 30\n};\n\n// オプショナルプロパティ\nlet config: { host: string; port?: number } = {\n    host: \"localhost\"\n};\n\n// 読み取り専用プロパティ\nlet point: { readonly x: number; readonly y: number } = {\n    x: 10,\n    y: 20\n};\n\n// インデックスシグネチャ\nlet dict: { [key: string]: number } = {\n    apple: 1,\n    banana: 2\n};\n\n// Record 型\nlet record: Record&#x3C;string, number> = {\n    a: 1,\n    b: 2\n};\n</code></pre>\n<h2>インターフェースと型エイリアス</h2>\n<h3>インターフェース</h3>\n<pre><code class=\"language-typescript\">// インターフェース定義\ninterface User {\n    id: number;\n    name: string;\n    email: string;\n    age?: number;  // オプショナル\n    readonly createdAt: Date;  // 読み取り専用\n}\n\n// インターフェース拡張\ninterface Admin extends User {\n    role: \"admin\";\n    permissions: string[];\n}\n\n// 複数インターフェース継承\ninterface SuperAdmin extends User, Admin {\n    superPower: boolean;\n}\n\n// 関数インターフェース\ninterface SearchFunc {\n    (query: string, limit?: number): Promise&#x3C;Result[]>;\n}\n\n// 呼び出し可能インターフェース\ninterface CallableUser {\n    (): void;\n    name: string;\n}\n\n// インデックスインターフェース\ninterface StringArray {\n    [index: number]: string;\n}\n</code></pre>\n<h3>型エイリアス</h3>\n<pre><code class=\"language-typescript\">// 型エイリアス\ntype ID = string | number;\ntype Point = { x: number; y: number };\ntype Callback = (data: string) => void;\n\n// ユニオン型\ntype Status = \"pending\" | \"success\" | \"error\";\ntype Result = string | number | null;\n\n// 交差型\ntype Employee = User &#x26; { department: string };\n\n// 条件型\ntype NonNullable&#x3C;T> = T extends null | undefined ? never : T;\n\n// マップ型\ntype Readonly&#x3C;T> = {\n    readonly [P in keyof T]: T[P];\n};\n\ntype Partial&#x3C;T> = {\n    [P in keyof T]?: T[P];\n};\n</code></pre>\n<h2>関数型</h2>\n<h3>関数宣言</h3>\n<pre><code class=\"language-typescript\">// 関数型宣言\nfunction add(a: number, b: number): number {\n    return a + b;\n}\n\n// アロー関数\nconst multiply = (a: number, b: number): number => a * b;\n\n// オプショナル引数\nfunction greet(name: string, greeting?: string): string {\n    return `${greeting ?? \"Hello\"}, ${name}!`;\n}\n\n// デフォルト引数\nfunction createUser(name: string, role: string = \"user\"): User {\n    return { name, role };\n}\n\n// 残余引数\nfunction sum(...numbers: number[]): number {\n    return numbers.reduce((a, b) => a + b, 0);\n}\n\n// 関数オーバーロード\nfunction format(value: string): string;\nfunction format(value: number): string;\nfunction format(value: string | number): string {\n    return String(value);\n}\n</code></pre>\n<h3>ジェネリック関数</h3>\n<pre><code class=\"language-typescript\">// ジェネリック関数\nfunction identity&#x3C;T>(value: T): T {\n    return value;\n}\n\n// 複数ジェネリック引数\nfunction pair&#x3C;T, U>(first: T, second: U): [T, U] {\n    return [first, second];\n}\n\n// ジェネリック制約\nfunction getLength&#x3C;T extends { length: number }>(value: T): number {\n    return value.length;\n}\n\n// keyof 制約\nfunction getProperty&#x3C;T, K extends keyof T>(obj: T, key: K): T[K] {\n    return obj[key];\n}\n\n// デフォルトジェネリック型\nfunction createArray&#x3C;T = string>(length: number, value: T): T[] {\n    return Array(length).fill(value);\n}\n</code></pre>\n<h2>クラス</h2>\n<pre><code class=\"language-typescript\">// クラス定義\nclass Person {\n    // プロパティ\n    public name: string;\n    private age: number;\n    protected email: string;\n    readonly id: number;\n\n    // 静的プロパティ\n    static count = 0;\n\n    // コンストラクタ\n    constructor(name: string, age: number) {\n        this.name = name;\n        this.age = age;\n        this.email = \"\";\n        this.id = ++Person.count;\n    }\n\n    // メソッド\n    greet(): string {\n        return `Hello, I'm ${this.name}`;\n    }\n\n    // getter/setter\n    get fullInfo(): string {\n        return `${this.name} (${this.age})`;\n    }\n\n    set userAge(age: number) {\n        if (age > 0) this.age = age;\n    }\n}\n\n// 継承\nclass Employee extends Person {\n    department: string;\n\n    constructor(name: string, age: number, department: string) {\n        super(name, age);\n        this.department = department;\n    }\n\n    override greet(): string {\n        return `${super.greet()}, from ${this.department}`;\n    }\n}\n\n// 抽象クラス\nabstract class Shape {\n    abstract area(): number;\n    abstract perimeter(): number;\n\n    describe(): string {\n        return `Area: ${this.area()}`;\n    }\n}\n\n// インターフェース実装\ninterface Printable {\n    print(): void;\n}\n\nclass Document implements Printable {\n    print(): void {\n        console.log(\"Printing...\");\n    }\n}\n</code></pre>\n<h2>高度な型</h2>\n<h3>ユーティリティ型</h3>\n<pre><code class=\"language-typescript\">interface User {\n    id: number;\n    name: string;\n    email: string;\n    age: number;\n}\n\n// Partial - すべてオプショナル\ntype PartialUser = Partial&#x3C;User>;\n\n// Required - すべて必須\ntype RequiredUser = Required&#x3C;User>;\n\n// Readonly - すべて読み取り専用\ntype ReadonlyUser = Readonly&#x3C;User>;\n\n// Pick - 一部を選択\ntype UserBasic = Pick&#x3C;User, \"id\" | \"name\">;\n\n// Omit - 一部を除外\ntype UserWithoutEmail = Omit&#x3C;User, \"email\">;\n\n// Record - オブジェクト型構築\ntype UserRecord = Record&#x3C;string, User>;\n\n// Exclude - ユニオンから除外\ntype Status = \"pending\" | \"success\" | \"error\";\ntype SuccessStatus = Exclude&#x3C;Status, \"error\">;\n\n// Extract - ユニオンから抽出\ntype ErrorStatus = Extract&#x3C;Status, \"error\" | \"pending\">;\n\n// ReturnType - 関数の戻り値型\nfunction getUser() { return { id: 1, name: \"Alice\" }; }\ntype UserType = ReturnType&#x3C;typeof getUser>;\n\n// Parameters - 関数の引数型\ntype GetUserParams = Parameters&#x3C;typeof getUser>;\n</code></pre>\n<h3>条件型</h3>\n<pre><code class=\"language-typescript\">// 基本条件型\ntype IsString&#x3C;T> = T extends string ? true : false;\n\n// infer キーワード\ntype UnwrapPromise&#x3C;T> = T extends Promise&#x3C;infer U> ? U : T;\ntype ArrayElement&#x3C;T> = T extends (infer E)[] ? E : never;\n\n// 分散条件型\ntype ToArray&#x3C;T> = T extends any ? T[] : never;\ntype Result = ToArray&#x3C;string | number>;  // string[] | number[]\n\n// テンプレートリテラル型\ntype EventName = `on${Capitalize&#x3C;\"click\" | \"focus\" | \"blur\">}`;\n// \"onClick\" | \"onFocus\" | \"onBlur\"\n</code></pre>\n<h3>型ガード</h3>\n<pre><code class=\"language-typescript\">// typeof ガード\nfunction process(value: string | number) {\n    if (typeof value === \"string\") {\n        return value.toUpperCase();\n    }\n    return value.toFixed(2);\n}\n\n// instanceof ガード\nfunction handleError(error: Error | string) {\n    if (error instanceof Error) {\n        return error.message;\n    }\n    return error;\n}\n\n// in ガード\ninterface Cat { meow(): void; }\ninterface Dog { bark(): void; }\n\nfunction speak(animal: Cat | Dog) {\n    if (\"meow\" in animal) {\n        animal.meow();\n    } else {\n        animal.bark();\n    }\n}\n\n// カスタム型ガード\nfunction isString(value: unknown): value is string {\n    return typeof value === \"string\";\n}\n\n// アサーション関数\nfunction assertNonNull&#x3C;T>(value: T): asserts value is NonNullable&#x3C;T> {\n    if (value === null || value === undefined) {\n        throw new Error(\"Value is null or undefined\");\n    }\n}\n</code></pre>\n<h2>モジュールと名前空間</h2>\n<pre><code class=\"language-typescript\">// エクスポート\nexport interface User { name: string; }\nexport type ID = string | number;\nexport const VERSION = \"1.0.0\";\nexport default class App { }\n\n// インポート\nimport App, { User, ID, VERSION } from \"./app\";\nimport type { User } from \"./app\";  // 型のみインポート\nimport * as Utils from \"./utils\";\n\n// 動的インポート\nconst module = await import(\"./module\");\n\n// 型宣言ファイル (.d.ts)\ndeclare module \"some-library\" {\n    export function doSomething(): void;\n}\n\n// グローバル宣言\ndeclare global {\n    interface Window {\n        myGlobal: string;\n    }\n}\n</code></pre>\n<h2>デコレータ</h2>\n<pre><code class=\"language-typescript\">// クラスデコレータ\nfunction sealed(constructor: Function) {\n    Object.seal(constructor);\n    Object.seal(constructor.prototype);\n}\n\n@sealed\nclass Greeter { }\n\n// メソッドデコレータ\nfunction log(target: any, key: string, descriptor: PropertyDescriptor) {\n    const original = descriptor.value;\n    descriptor.value = function(...args: any[]) {\n        console.log(`Calling ${key} with`, args);\n        return original.apply(this, args);\n    };\n    return descriptor;\n}\n\nclass Calculator {\n    @log\n    add(a: number, b: number) {\n        return a + b;\n    }\n}\n\n// プロパティデコレータ\nfunction readonly(target: any, key: string) {\n    Object.defineProperty(target, key, {\n        writable: false\n    });\n}\n</code></pre>\n<h2>設定とツール</h2>\n<h3>tsconfig.json</h3>\n<pre><code class=\"language-json\">{\n    \"compilerOptions\": {\n        \"target\": \"ES2022\",\n        \"module\": \"ESNext\",\n        \"moduleResolution\": \"bundler\",\n        \"strict\": true,\n        \"noImplicitAny\": true,\n        \"strictNullChecks\": true,\n        \"esModuleInterop\": true,\n        \"skipLibCheck\": true,\n        \"declaration\": true,\n        \"outDir\": \"./dist\",\n        \"rootDir\": \"./src\",\n        \"baseUrl\": \"./\",\n        \"paths\": {\n            \"@/*\": [\"src/*\"]\n        }\n    },\n    \"include\": [\"src/**/*\"],\n    \"exclude\": [\"node_modules\"]\n}\n</code></pre>\n<h2>まとめ</h2>\n<p>TypeScript のポイント：</p>\n<ol>\n<li><strong>型安全</strong> - コンパイル時エラー検出</li>\n<li><strong>型推論</strong> - スマートな推定で冗長性削減</li>\n<li><strong>高度な型</strong> - ジェネリクス、条件型、マップ型</li>\n<li><strong>段階的</strong> - JavaScript プロジェクトを段階的に移行</li>\n<li><strong>豊富なエコシステム</strong> - @types 型定義ライブラリ</li>\n</ol>\n"
}