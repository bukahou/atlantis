{
  "slug": "shell",
  "meta": {
    "title": "Shell スクリプト基礎",
    "description": "Bash/Shell スクリプトプログラミング、よく使うコマンドと自動化運用",
    "order": 2,
    "tags": [
      "shell",
      "bash",
      "scripting",
      "automation"
    ]
  },
  "content": "<h1>Shell スクリプト基礎</h1>\n<h2>Shell 概要</h2>\n<p>Shell はオペレーティングシステムのコマンドラインインタープリタで、Bash (Bourne Again Shell) は最もよく使われる Shell です。システム管理、自動化運用、DevOps プロセスで広く使用されています。</p>\n<pre><code>Shell の特徴\n├── システム操作 - OS と直接対話\n├── スクリプト自動化 - バッチタスク実行\n├── パイプ機構 - コマンドの組み合わせ処理\n├── テキスト処理 - 強力なテキスト操作能力\n└── クロスプラットフォーム - Linux/macOS/WSL\n</code></pre>\n<h2>基本構文</h2>\n<h3>スクリプト構造</h3>\n<pre><code class=\"language-bash\">#!/bin/bash\n# Shebang でインタープリタ指定\n\n# これはコメント\n\n# 変数\nNAME=\"Shell\"\nVERSION=5\n\n# 変数の使用\necho \"Welcome to $NAME\"\necho \"Version: ${VERSION}\"\n\n# コマンド実行\ncurrent_date=$(date +%Y-%m-%d)\nfile_count=`ls | wc -l`\n\n# 終了ステータス\nexit 0\n</code></pre>\n<h3>変数</h3>\n<pre><code class=\"language-bash\"># 変数代入 (等号の両側にスペース不可)\nname=\"Alice\"\nage=30\nreadonly PI=3.14159\n\n# 文字列\nstr1=\"Hello\"\nstr2='World'\ncombined=\"$str1 $str2\"\nlength=${#str1}  # 文字列長\n\n# 文字列操作\n${str:0:5}       # 部分文字列 (0から5文字)\n${str#*/}        # 最短プレフィックス削除\n${str##*/}       # 最長プレフィックス削除\n${str%/*}        # 最短サフィックス削除\n${str%%/*}       # 最長サフィックス削除\n${str/old/new}   # 最初を置換\n${str//old/new}  # すべて置換\n\n# デフォルト値\n${var:-default}  # var 未設定なら default\n${var:=default}  # var 未設定なら default を代入\n${var:+value}    # var 設定済みなら value\n${var:?error}    # var 未設定ならエラー\n\n# 配列\narr=(a b c d e)\necho ${arr[0]}       # 最初の要素\necho ${arr[@]}       # すべての要素\necho ${#arr[@]}      # 配列長\narr+=(f g)           # 要素追加\n\n# 連想配列 (Bash 4+)\ndeclare -A map\nmap[name]=\"Alice\"\nmap[age]=30\necho ${map[name]}\necho ${!map[@]}      # すべてのキー\n</code></pre>\n<h3>特殊変数</h3>\n<pre><code class=\"language-bash\">$0          # スクリプト名\n$1 $2 ...   # 位置パラメータ\n$#          # 引数の数\n$@          # すべての引数 (個別文字列)\n$*          # すべての引数 (単一文字列)\n$?          # 前のコマンドの終了ステータス\n$$          # 現在のスクリプト PID\n$!          # バックグラウンドプロセス PID\n$_          # 前のコマンドの最後の引数\n</code></pre>\n<h2>制御フロー</h2>\n<h3>条件分岐</h3>\n<pre><code class=\"language-bash\"># if-elif-else\nif [ \"$age\" -ge 18 ]; then\n    echo \"Adult\"\nelif [ \"$age\" -ge 13 ]; then\n    echo \"Teen\"\nelse\n    echo \"Child\"\nfi\n\n# [[ ]] 拡張テスト (推奨)\nif [[ \"$name\" == \"Alice\" &#x26;&#x26; \"$age\" -gt 20 ]]; then\n    echo \"Match\"\nfi\n\n# 正規表現マッチ\nif [[ \"$email\" =~ ^[a-zA-Z0-9]+@[a-zA-Z0-9]+\\.[a-zA-Z]+$ ]]; then\n    echo \"Valid email\"\nfi\n\n# ファイルテスト\nif [[ -f \"$file\" ]]; then echo \"ファイル\"; fi\nif [[ -d \"$dir\" ]]; then echo \"ディレクトリ\"; fi\nif [[ -e \"$path\" ]]; then echo \"存在する\"; fi\nif [[ -r \"$file\" ]]; then echo \"読み取り可能\"; fi\nif [[ -w \"$file\" ]]; then echo \"書き込み可能\"; fi\nif [[ -x \"$file\" ]]; then echo \"実行可能\"; fi\nif [[ -s \"$file\" ]]; then echo \"空でない\"; fi\n\n# 文字列テスト\nif [[ -z \"$str\" ]]; then echo \"空文字列\"; fi\nif [[ -n \"$str\" ]]; then echo \"空でない文字列\"; fi\n\n# 数値比較\n# -eq (等しい) -ne (等しくない) -lt (より小さい)\n# -le (以下) -gt (より大きい) -ge (以上)\n</code></pre>\n<h3>case 文</h3>\n<pre><code class=\"language-bash\">case \"$option\" in\n    start)\n        echo \"Starting...\"\n        ;;\n    stop)\n        echo \"Stopping...\"\n        ;;\n    restart|reload)\n        echo \"Restarting...\"\n        ;;\n    *)\n        echo \"Unknown option\"\n        exit 1\n        ;;\nesac\n</code></pre>\n<h3>ループ</h3>\n<pre><code class=\"language-bash\"># for ループ\nfor i in 1 2 3 4 5; do\n    echo $i\ndone\n\nfor i in {1..10}; do\n    echo $i\ndone\n\nfor i in {0..100..10}; do  # ステップ 10\n    echo $i\ndone\n\nfor file in *.txt; do\n    echo \"Processing $file\"\ndone\n\n# C 言語スタイル for\nfor ((i=0; i&#x3C;10; i++)); do\n    echo $i\ndone\n\n# while ループ\ncount=0\nwhile [ $count -lt 5 ]; do\n    echo $count\n    ((count++))\ndone\n\n# ファイル読み込み\nwhile IFS= read -r line; do\n    echo \"$line\"\ndone &#x3C; file.txt\n\n# until ループ\nuntil [ $count -eq 0 ]; do\n    ((count--))\ndone\n\n# ループ制御\nbreak       # ループ終了\ncontinue    # スキップ\n</code></pre>\n<h2>関数</h2>\n<pre><code class=\"language-bash\"># 関数定義\nfunction greet() {\n    echo \"Hello, $1!\"\n}\n\n# 省略形\nsay_bye() {\n    echo \"Goodbye, $1!\"\n    return 0\n}\n\n# 呼び出し\ngreet \"Alice\"\nsay_bye \"Bob\"\n\n# 戻り値取得\nresult=$(greet \"World\")\nstatus=$?\n\n# ローカル変数\ncalculate() {\n    local result=$(( $1 + $2 ))\n    echo $result\n}\n\nsum=$(calculate 10 20)\n\n# 引数処理\nprocess_args() {\n    while [[ $# -gt 0 ]]; do\n        case \"$1\" in\n            -n|--name)\n                name=\"$2\"\n                shift 2\n                ;;\n            -v|--verbose)\n                verbose=1\n                shift\n                ;;\n            *)\n                echo \"Unknown: $1\"\n                shift\n                ;;\n        esac\n    done\n}\n</code></pre>\n<h2>入出力</h2>\n<h3>リダイレクト</h3>\n<pre><code class=\"language-bash\"># 出力リダイレクト\ncommand > file      # 上書き\ncommand >> file     # 追加\ncommand 2> file     # エラー出力\ncommand &#x26;> file     # すべての出力\ncommand 2>&#x26;1        # エラーを標準出力へ\n\n# 入力リダイレクト\ncommand &#x3C; file\ncommand &#x3C;&#x3C; EOF\n複数行入力\nEOF\n\n# Here String\ncommand &#x3C;&#x3C;&#x3C; \"string\"\n\n# 出力破棄\ncommand > /dev/null 2>&#x26;1\ncommand &#x26;> /dev/null\n</code></pre>\n<h3>パイプ</h3>\n<pre><code class=\"language-bash\"># 基本パイプ\ncat file | grep \"pattern\" | sort | uniq\n\n# よく使う組み合わせ\nps aux | grep nginx\nls -la | head -10\ncat log.txt | tail -100 | grep ERROR\n\n# tee ファイルと画面に同時出力\ncommand | tee output.txt\ncommand | tee -a output.txt  # 追加\n\n# xargs 引数渡し\nfind . -name \"*.log\" | xargs rm\nfind . -name \"*.txt\" | xargs -I {} cp {} backup/\n</code></pre>\n<h3>ユーザー入力</h3>\n<pre><code class=\"language-bash\"># 入力読み取り\nread -p \"Enter name: \" name\nread -s -p \"Enter password: \" password  # 非表示\nread -t 5 -p \"Quick! \" answer  # タイムアウト\n\n# 選択メニュー\nselect opt in \"Option1\" \"Option2\" \"Quit\"; do\n    case $opt in\n        \"Option1\") echo \"Selected 1\" ;;\n        \"Option2\") echo \"Selected 2\" ;;\n        \"Quit\") break ;;\n    esac\ndone\n</code></pre>\n<h2>テキスト処理</h2>\n<h3>grep</h3>\n<pre><code class=\"language-bash\">grep \"pattern\" file\ngrep -i \"pattern\" file      # 大文字小文字無視\ngrep -r \"pattern\" dir/      # 再帰検索\ngrep -n \"pattern\" file      # 行番号表示\ngrep -v \"pattern\" file      # 逆マッチ\ngrep -E \"regex\" file        # 拡張正規表現\ngrep -c \"pattern\" file      # カウント\ngrep -l \"pattern\" *.txt     # ファイル名のみ\ngrep -A 3 \"pattern\" file    # 後3行\ngrep -B 3 \"pattern\" file    # 前3行\n</code></pre>\n<h3>sed</h3>\n<pre><code class=\"language-bash\"># 置換\nsed 's/old/new/' file       # 最初を置換\nsed 's/old/new/g' file      # すべて置換\nsed -i 's/old/new/g' file   # ファイル直接編集\n\n# 削除\nsed '/pattern/d' file       # マッチ行削除\nsed '1d' file               # 1行目削除\nsed '1,5d' file             # 1-5行削除\n\n# 表示\nsed -n '5p' file            # 5行目表示\nsed -n '1,10p' file         # 1-10行表示\nsed -n '/pattern/p' file    # マッチ行表示\n\n# 挿入\nsed '3i\\new line' file      # 3行目前に挿入\nsed '3a\\new line' file      # 3行目後に挿入\n</code></pre>\n<h3>awk</h3>\n<pre><code class=\"language-bash\"># 基本用法\nawk '{print $1}' file           # 1列目表示\nawk '{print $1, $3}' file       # 1列目と3列目\nawk -F: '{print $1}' /etc/passwd  # 区切り文字指定\n\n# 条件フィルタ\nawk '$3 > 100 {print $1}' file\nawk '/pattern/ {print}' file\n\n# 組み込み変数\nawk '{print NR, $0}' file   # NR 行番号\nawk '{print NF}' file       # NF フィールド数\nawk 'END {print NR}' file   # 総行数\n\n# 計算\nawk '{sum += $1} END {print sum}' file\nawk '{sum += $1; count++} END {print sum/count}' file\n\n# BEGIN/END\nawk 'BEGIN {print \"Start\"} {print} END {print \"End\"}' file\n</code></pre>\n<h2>よく使うコマンド</h2>\n<h3>ファイル操作</h3>\n<pre><code class=\"language-bash\"># 検索\nfind . -name \"*.txt\"\nfind . -type f -mtime -7     # 7日以内に変更\nfind . -size +100M           # 100M より大きい\nfind . -name \"*.log\" -exec rm {} \\;\n\n# 圧縮・展開\ntar -czvf archive.tar.gz dir/\ntar -xzvf archive.tar.gz\nzip -r archive.zip dir/\nunzip archive.zip\n\n# 権限\nchmod 755 file\nchmod +x script.sh\nchown user:group file\n</code></pre>\n<h3>プロセス管理</h3>\n<pre><code class=\"language-bash\"># プロセス確認\nps aux\nps aux | grep nginx\npgrep -f \"pattern\"\ntop\nhtop\n\n# プロセス制御\nkill PID\nkill -9 PID          # 強制終了\nkillall process_name\npkill -f \"pattern\"\n\n# バックグラウンド実行\ncommand &#x26;\nnohup command &#x26;\nnohup command > output.log 2>&#x26;1 &#x26;\n</code></pre>\n<h3>ネットワーク</h3>\n<pre><code class=\"language-bash\"># ネットワーク診断\nping host\ncurl -I http://example.com\nwget http://example.com/file\nnc -zv host port\n\n# ポート確認\nnetstat -tlnp\nss -tlnp\nlsof -i :8080\n</code></pre>\n<h2>実用スクリプトパターン</h2>\n<h3>エラー処理</h3>\n<pre><code class=\"language-bash\">#!/bin/bash\nset -e          # エラー時終了\nset -u          # 未定義変数でエラー\nset -o pipefail # パイプエラー検出\nset -x          # デバッグモード\n\n# クリーンアップ関数\ncleanup() {\n    rm -f \"$temp_file\"\n}\ntrap cleanup EXIT\n\n# エラー処理\nerror_exit() {\n    echo \"Error: $1\" >&#x26;2\n    exit 1\n}\n\n# 使用\ncommand || error_exit \"Command failed\"\n</code></pre>\n<h3>ログ記録</h3>\n<pre><code class=\"language-bash\">#!/bin/bash\nLOG_FILE=\"/var/log/myscript.log\"\n\nlog() {\n    local level=$1\n    shift\n    echo \"[$(date '+%Y-%m-%d %H:%M:%S')] [$level] $*\" | tee -a \"$LOG_FILE\"\n}\n\nlog INFO \"Script started\"\nlog ERROR \"Something went wrong\"\nlog INFO \"Script finished\"\n</code></pre>\n<h3>設定ファイル解析</h3>\n<pre><code class=\"language-bash\">#!/bin/bash\n# config.conf: KEY=VALUE 形式\n\nif [[ -f config.conf ]]; then\n    source config.conf\nfi\n\n# または行ごとに解析\nwhile IFS='=' read -r key value; do\n    [[ \"$key\" =~ ^#.*$ ]] &#x26;&#x26; continue\n    [[ -z \"$key\" ]] &#x26;&#x26; continue\n    declare \"$key=$value\"\ndone &#x3C; config.conf\n</code></pre>\n<h2>まとめ</h2>\n<p>Shell スクリプトのポイント：</p>\n<ol>\n<li><strong>システム操作</strong> - ファイル、プロセス、ネットワーク操作</li>\n<li><strong>テキスト処理</strong> - grep/sed/awk 三銃士</li>\n<li><strong>パイプ機構</strong> - コマンド組み合わせの強力さ</li>\n<li><strong>自動化</strong> - バッチタスク、定期実行タスク</li>\n<li><strong>運用必須</strong> - システム管理、デプロイスクリプト</li>\n</ol>\n"
}