{
  "slug": "circuit-breaker",
  "meta": {
    "title": "サーキットブレーカーとフォールバック",
    "description": "マイクロサービスのサーキットブレーカーパターン、サービス降格と耐障害メカニズム",
    "order": 3,
    "tags": [
      "microservices",
      "circuit-breaker",
      "fallback",
      "resilience"
    ]
  },
  "content": "<h1>サーキットブレーカーとフォールバック</h1>\n<h2>サーキットブレーカー概要</h2>\n<p>サーキットブレーカーパターンはカスケード障害を防ぎ、下流サービスが利用不可の場合に高速フェイルし、システム全体の安定性を保護します。</p>\n<pre><code>サーキットブレーカー状態機械\n├── CLOSED (閉) - 正常状態、リクエスト通過\n├── OPEN (開) - 遮断状態、リクエスト即座に失敗\n└── HALF_OPEN (半開) - 探査状態、部分的にリクエスト許可\n\n状態遷移\nCLOSED -> OPEN: 失敗率が閾値超過\nOPEN -> HALF_OPEN: タイムアウト後に探査\nHALF_OPEN -> CLOSED: 探査成功\nHALF_OPEN -> OPEN: 探査失敗\n</code></pre>\n<h2>サーキットブレーカー実装</h2>\n<h3>基本実装</h3>\n<pre><code class=\"language-go\">// サーキットブレーカー\ntype CircuitBreaker struct {\n    mu           sync.RWMutex\n    state        State\n    failureCount int\n    successCount int\n    lastFailure  time.Time\n\n    // 設定\n    failureThreshold int\n    successThreshold int\n    timeout          time.Duration\n}\n\ntype State int\n\nconst (\n    StateClosed State = iota\n    StateOpen\n    StateHalfOpen\n)\n\nfunc NewCircuitBreaker(failureThreshold, successThreshold int, timeout time.Duration) *CircuitBreaker {\n    return &#x26;CircuitBreaker{\n        state:            StateClosed,\n        failureThreshold: failureThreshold,\n        successThreshold: successThreshold,\n        timeout:          timeout,\n    }\n}\n\nfunc (cb *CircuitBreaker) Execute(fn func() error) error {\n    if !cb.allowRequest() {\n        return ErrCircuitOpen\n    }\n\n    err := fn()\n    cb.recordResult(err)\n    return err\n}\n\nfunc (cb *CircuitBreaker) allowRequest() bool {\n    cb.mu.RLock()\n    defer cb.mu.RUnlock()\n\n    switch cb.state {\n    case StateClosed:\n        return true\n    case StateOpen:\n        if time.Since(cb.lastFailure) > cb.timeout {\n            cb.mu.RUnlock()\n            cb.mu.Lock()\n            cb.state = StateHalfOpen\n            cb.mu.Unlock()\n            cb.mu.RLock()\n            return true\n        }\n        return false\n    case StateHalfOpen:\n        return true\n    }\n    return false\n}\n\nfunc (cb *CircuitBreaker) recordResult(err error) {\n    cb.mu.Lock()\n    defer cb.mu.Unlock()\n\n    if err != nil {\n        cb.failureCount++\n        cb.lastFailure = time.Now()\n\n        if cb.state == StateHalfOpen {\n            cb.state = StateOpen\n        } else if cb.failureCount >= cb.failureThreshold {\n            cb.state = StateOpen\n        }\n    } else {\n        cb.successCount++\n\n        if cb.state == StateHalfOpen &#x26;&#x26; cb.successCount >= cb.successThreshold {\n            cb.state = StateClosed\n            cb.failureCount = 0\n            cb.successCount = 0\n        }\n    }\n}\n</code></pre>\n<h3>スライディングウィンドウ統計</h3>\n<pre><code class=\"language-go\">// スライディングウィンドウサーキットブレーカー\ntype SlidingWindowBreaker struct {\n    mu          sync.RWMutex\n    state       State\n    window      *SlidingWindow\n    config      Config\n    lastFailure time.Time\n}\n\ntype Config struct {\n    WindowSize        time.Duration\n    FailureRateThresh float64\n    MinRequests       int\n    HalfOpenRequests  int\n    Timeout           time.Duration\n}\n\ntype SlidingWindow struct {\n    buckets    []Bucket\n    bucketSize time.Duration\n    current    int\n}\n\ntype Bucket struct {\n    success int\n    failure int\n    time    time.Time\n}\n\nfunc (sw *SlidingWindow) Record(success bool) {\n    sw.rotate()\n    if success {\n        sw.buckets[sw.current].success++\n    } else {\n        sw.buckets[sw.current].failure++\n    }\n}\n\nfunc (sw *SlidingWindow) FailureRate() float64 {\n    sw.rotate()\n    var total, failures int\n    for _, b := range sw.buckets {\n        total += b.success + b.failure\n        failures += b.failure\n    }\n    if total == 0 {\n        return 0\n    }\n    return float64(failures) / float64(total)\n}\n\nfunc (sw *SlidingWindow) TotalRequests() int {\n    var total int\n    for _, b := range sw.buckets {\n        total += b.success + b.failure\n    }\n    return total\n}\n</code></pre>\n<h2>サービスフォールバック</h2>\n<h3>フォールバック戦略</h3>\n<pre><code class=\"language-go\">// フォールバックハンドラー\ntype Fallback struct {\n    primary   func() (interface{}, error)\n    fallback  func(error) (interface{}, error)\n    breaker   *CircuitBreaker\n}\n\nfunc (f *Fallback) Execute() (interface{}, error) {\n    // プライマリロジック試行\n    result, err := f.breaker.Execute(func() error {\n        var execErr error\n        result, execErr = f.primary()\n        return execErr\n    })\n\n    if err != nil {\n        // フォールバック実行\n        return f.fallback(err)\n    }\n\n    return result, nil\n}\n\n// 使用例\nfallback := &#x26;Fallback{\n    primary: func() (interface{}, error) {\n        return userService.GetUser(userID)\n    },\n    fallback: func(err error) (interface{}, error) {\n        // キャッシュデータまたはデフォルト値を返す\n        if cached, ok := cache.Get(userID); ok {\n            return cached, nil\n        }\n        return &#x26;User{Name: \"Unknown\"}, nil\n    },\n    breaker: circuitBreaker,\n}\n\nuser, _ := fallback.Execute()\n</code></pre>\n<h3>多段フォールバック</h3>\n<pre><code class=\"language-go\">// 多段フォールバックチェーン\ntype FallbackChain struct {\n    handlers []func() (interface{}, error)\n}\n\nfunc (fc *FallbackChain) Execute() (interface{}, error) {\n    var lastErr error\n\n    for _, handler := range fc.handlers {\n        result, err := handler()\n        if err == nil {\n            return result, nil\n        }\n        lastErr = err\n    }\n\n    return nil, lastErr\n}\n\n// 使用例\nchain := &#x26;FallbackChain{\n    handlers: []func() (interface{}, error){\n        // プライマリサービス\n        func() (interface{}, error) {\n            return primaryService.GetData()\n        },\n        // バックアップサービス\n        func() (interface{}, error) {\n            return backupService.GetData()\n        },\n        // ローカルキャッシュ\n        func() (interface{}, error) {\n            return localCache.Get(key)\n        },\n        // デフォルト値\n        func() (interface{}, error) {\n            return defaultValue, nil\n        },\n    },\n}\n</code></pre>\n<h2>Hystrix スタイル実装</h2>\n<pre><code class=\"language-go\">// Hystrix スタイルコマンド\ntype Command struct {\n    Name     string\n    Run      func() (interface{}, error)\n    Fallback func(error) (interface{}, error)\n\n    timeout time.Duration\n    breaker *CircuitBreaker\n}\n\nfunc (c *Command) Execute() (interface{}, error) {\n    // サーキット状態チェック\n    if !c.breaker.allowRequest() {\n        return c.Fallback(ErrCircuitOpen)\n    }\n\n    // タイムアウト制御\n    ctx, cancel := context.WithTimeout(context.Background(), c.timeout)\n    defer cancel()\n\n    resultCh := make(chan interface{}, 1)\n    errCh := make(chan error, 1)\n\n    go func() {\n        result, err := c.Run()\n        if err != nil {\n            errCh &#x3C;- err\n        } else {\n            resultCh &#x3C;- result\n        }\n    }()\n\n    select {\n    case result := &#x3C;-resultCh:\n        c.breaker.recordResult(nil)\n        return result, nil\n    case err := &#x3C;-errCh:\n        c.breaker.recordResult(err)\n        return c.Fallback(err)\n    case &#x3C;-ctx.Done():\n        c.breaker.recordResult(ctx.Err())\n        return c.Fallback(ctx.Err())\n    }\n}\n</code></pre>\n<h2>バルクヘッド分離</h2>\n<pre><code class=\"language-go\">// バルクヘッドパターン\ntype Bulkhead struct {\n    name      string\n    semaphore chan struct{}\n    timeout   time.Duration\n}\n\nfunc NewBulkhead(name string, maxConcurrent int, timeout time.Duration) *Bulkhead {\n    return &#x26;Bulkhead{\n        name:      name,\n        semaphore: make(chan struct{}, maxConcurrent),\n        timeout:   timeout,\n    }\n}\n\nfunc (b *Bulkhead) Execute(fn func() error) error {\n    select {\n    case b.semaphore &#x3C;- struct{}{}:\n        defer func() { &#x3C;-b.semaphore }()\n        return fn()\n    case &#x3C;-time.After(b.timeout):\n        return ErrBulkheadTimeout\n    }\n}\n\n// スレッドプール分離\ntype ThreadPoolBulkhead struct {\n    pool *workerpool.Pool\n}\n\nfunc (tp *ThreadPoolBulkhead) Submit(task func()) error {\n    return tp.pool.Submit(task)\n}\n</code></pre>\n<h2>レート制限</h2>\n<h3>トークンバケット</h3>\n<pre><code class=\"language-go\">// トークンバケット制限\ntype TokenBucket struct {\n    capacity   int64\n    tokens     int64\n    refillRate int64 // 秒あたり補充\n    lastRefill time.Time\n    mu         sync.Mutex\n}\n\nfunc (tb *TokenBucket) Allow() bool {\n    tb.mu.Lock()\n    defer tb.mu.Unlock()\n\n    tb.refill()\n\n    if tb.tokens > 0 {\n        tb.tokens--\n        return true\n    }\n    return false\n}\n\nfunc (tb *TokenBucket) refill() {\n    now := time.Now()\n    elapsed := now.Sub(tb.lastRefill).Seconds()\n    tb.tokens = min(tb.capacity, tb.tokens+int64(elapsed*float64(tb.refillRate)))\n    tb.lastRefill = now\n}\n</code></pre>\n<h3>リーキーバケット</h3>\n<pre><code class=\"language-go\">// リーキーバケット制限\ntype LeakyBucket struct {\n    capacity int64\n    water    int64\n    rate     int64 // 秒あたり漏出\n    lastLeak time.Time\n    mu       sync.Mutex\n}\n\nfunc (lb *LeakyBucket) Allow() bool {\n    lb.mu.Lock()\n    defer lb.mu.Unlock()\n\n    lb.leak()\n\n    if lb.water &#x3C; lb.capacity {\n        lb.water++\n        return true\n    }\n    return false\n}\n</code></pre>\n<h2>監視メトリクス</h2>\n<pre><code class=\"language-go\">// サーキットブレーカーメトリクス\ntype Metrics struct {\n    TotalRequests   *prometheus.CounterVec\n    FailedRequests  *prometheus.CounterVec\n    CircuitState    *prometheus.GaugeVec\n    ResponseTime    *prometheus.HistogramVec\n}\n\nfunc (m *Metrics) RecordRequest(name string, success bool, duration time.Duration) {\n    m.TotalRequests.WithLabelValues(name).Inc()\n    if !success {\n        m.FailedRequests.WithLabelValues(name).Inc()\n    }\n    m.ResponseTime.WithLabelValues(name).Observe(duration.Seconds())\n}\n\nfunc (m *Metrics) SetCircuitState(name string, state State) {\n    m.CircuitState.WithLabelValues(name).Set(float64(state))\n}\n</code></pre>\n<h2>まとめ</h2>\n<p>サーキットブレーカーとフォールバックのポイント：</p>\n<ol>\n<li><strong>サーキットブレーカー</strong> - 三状態遷移、カスケード障害防止</li>\n<li><strong>サービスフォールバック</strong> - キャッシュ、デフォルト値、バックアップサービス</li>\n<li><strong>バルクヘッド分離</strong> - リソース分離、並行性制限</li>\n<li><strong>レート制限</strong> - トークンバケット、リーキーバケット</li>\n<li><strong>監視</strong> - リアルタイムメトリクス、アラート発火</li>\n</ol>\n"
}