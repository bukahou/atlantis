{
  "slug": "grpc",
  "meta": {
    "title": "gRPC",
    "description": "gRPC プロトコル、Protocol Buffers とサービス間通信",
    "order": 3,
    "tags": [
      "api",
      "grpc",
      "protobuf",
      "rpc"
    ]
  },
  "content": "<h1>gRPC</h1>\n<h2>gRPC 概要</h2>\n<p>gRPC は Google が開発した高性能 RPC フレームワークで、Protocol Buffers をインターフェース定義言語とメッセージシリアライズ形式として使用します。</p>\n<pre><code>gRPC の特徴\n├── 高性能 - バイナリシリアライズ、HTTP/2\n├── 強い型付け - Protocol Buffers 定義\n├── 多言語対応 - 複数プログラミング言語サポート\n├── ストリーミング - 双方向ストリームサポート\n└── コード生成 - クライアント/サーバーコード自動生成\n</code></pre>\n<h2>Protocol Buffers</h2>\n<h3>基本構文</h3>\n<pre><code class=\"language-protobuf\">// user.proto\nsyntax = \"proto3\";\n\npackage user.v1;\n\noption go_package = \"github.com/example/user/v1\";\n\n// メッセージ定義\nmessage User {\n  string id = 1;\n  string name = 2;\n  string email = 3;\n  UserRole role = 4;\n  repeated string tags = 5;\n  optional string bio = 6;\n  google.protobuf.Timestamp created_at = 7;\n}\n\n// 列挙型\nenum UserRole {\n  USER_ROLE_UNSPECIFIED = 0;\n  USER_ROLE_ADMIN = 1;\n  USER_ROLE_USER = 2;\n  USER_ROLE_GUEST = 3;\n}\n\n// ネストメッセージ\nmessage Address {\n  string street = 1;\n  string city = 2;\n  string country = 3;\n}\n\nmessage UserProfile {\n  User user = 1;\n  Address address = 2;\n}\n</code></pre>\n<h3>スカラー型</h3>\n<pre><code class=\"language-protobuf\">// 数値型\nint32, int64       // 符号付き整数\nuint32, uint64     // 符号なし整数\nsint32, sint64     // 符号付き (ZigZag エンコード)\nfixed32, fixed64   // 固定長符号なし\nsfixed32, sfixed64 // 固定長符号付き\nfloat, double      // 浮動小数点\n\n// その他の型\nbool               // ブール値\nstring             // UTF-8 文字列\nbytes              // 任意バイト列\n</code></pre>\n<h3>サービス定義</h3>\n<pre><code class=\"language-protobuf\">// サービス定義\nservice UserService {\n  // 単項 RPC\n  rpc GetUser(GetUserRequest) returns (GetUserResponse);\n  rpc CreateUser(CreateUserRequest) returns (CreateUserResponse);\n  rpc UpdateUser(UpdateUserRequest) returns (UpdateUserResponse);\n  rpc DeleteUser(DeleteUserRequest) returns (DeleteUserResponse);\n\n  // サーバーストリーム\n  rpc ListUsers(ListUsersRequest) returns (stream User);\n\n  // クライアントストリーム\n  rpc CreateUsers(stream CreateUserRequest) returns (CreateUsersResponse);\n\n  // 双方向ストリーム\n  rpc Chat(stream ChatMessage) returns (stream ChatMessage);\n}\n\n// リクエストメッセージ\nmessage GetUserRequest {\n  string id = 1;\n}\n\nmessage GetUserResponse {\n  User user = 1;\n}\n\nmessage ListUsersRequest {\n  int32 page_size = 1;\n  string page_token = 2;\n  UserFilter filter = 3;\n}\n\nmessage UserFilter {\n  optional UserRole role = 1;\n  optional string name_contains = 2;\n}\n</code></pre>\n<h2>サービス実装</h2>\n<h3>Go サーバー</h3>\n<pre><code class=\"language-go\">// server.go\npackage main\n\nimport (\n    \"context\"\n    \"log\"\n    \"net\"\n\n    \"google.golang.org/grpc\"\n    pb \"github.com/example/user/v1\"\n)\n\ntype userServer struct {\n    pb.UnimplementedUserServiceServer\n    users map[string]*pb.User\n}\n\nfunc (s *userServer) GetUser(ctx context.Context, req *pb.GetUserRequest) (*pb.GetUserResponse, error) {\n    user, ok := s.users[req.Id]\n    if !ok {\n        return nil, status.Errorf(codes.NotFound, \"user not found: %s\", req.Id)\n    }\n    return &#x26;pb.GetUserResponse{User: user}, nil\n}\n\nfunc (s *userServer) CreateUser(ctx context.Context, req *pb.CreateUserRequest) (*pb.CreateUserResponse, error) {\n    user := &#x26;pb.User{\n        Id:    uuid.New().String(),\n        Name:  req.Name,\n        Email: req.Email,\n    }\n    s.users[user.Id] = user\n    return &#x26;pb.CreateUserResponse{User: user}, nil\n}\n\n// サーバーストリーム\nfunc (s *userServer) ListUsers(req *pb.ListUsersRequest, stream pb.UserService_ListUsersServer) error {\n    for _, user := range s.users {\n        if err := stream.Send(user); err != nil {\n            return err\n        }\n    }\n    return nil\n}\n\nfunc main() {\n    lis, _ := net.Listen(\"tcp\", \":50051\")\n    grpcServer := grpc.NewServer()\n    pb.RegisterUserServiceServer(grpcServer, &#x26;userServer{\n        users: make(map[string]*pb.User),\n    })\n    log.Fatal(grpcServer.Serve(lis))\n}\n</code></pre>\n<h3>Go クライアント</h3>\n<pre><code class=\"language-go\">// client.go\npackage main\n\nimport (\n    \"context\"\n    \"io\"\n    \"log\"\n\n    \"google.golang.org/grpc\"\n    \"google.golang.org/grpc/credentials/insecure\"\n    pb \"github.com/example/user/v1\"\n)\n\nfunc main() {\n    conn, _ := grpc.Dial(\"localhost:50051\",\n        grpc.WithTransportCredentials(insecure.NewCredentials()))\n    defer conn.Close()\n\n    client := pb.NewUserServiceClient(conn)\n\n    // 単項呼び出し\n    resp, err := client.GetUser(context.Background(), &#x26;pb.GetUserRequest{\n        Id: \"123\",\n    })\n    if err != nil {\n        log.Fatal(err)\n    }\n    log.Printf(\"User: %v\", resp.User)\n\n    // サーバーストリーム\n    stream, _ := client.ListUsers(context.Background(), &#x26;pb.ListUsersRequest{})\n    for {\n        user, err := stream.Recv()\n        if err == io.EOF {\n            break\n        }\n        log.Printf(\"User: %v\", user)\n    }\n}\n</code></pre>\n<h2>ストリーミング</h2>\n<h3>4 つのモード</h3>\n<pre><code>1. 単項 RPC\n   Client -> Server: Request\n   Server -> Client: Response\n\n2. サーバーストリーム\n   Client -> Server: Request\n   Server -> Client: Response1, Response2, ...\n\n3. クライアントストリーム\n   Client -> Server: Request1, Request2, ...\n   Server -> Client: Response\n\n4. 双方向ストリーム\n   Client &#x3C;-> Server: 双方向メッセージストリーム\n</code></pre>\n<h3>双方向ストリーム例</h3>\n<pre><code class=\"language-go\">// サーバー\nfunc (s *chatServer) Chat(stream pb.ChatService_ChatServer) error {\n    for {\n        msg, err := stream.Recv()\n        if err == io.EOF {\n            return nil\n        }\n        // メッセージ処理\n        response := &#x26;pb.ChatMessage{\n            Content: \"Echo: \" + msg.Content,\n        }\n        if err := stream.Send(response); err != nil {\n            return err\n        }\n    }\n}\n\n// クライアント\nstream, _ := client.Chat(context.Background())\ngo func() {\n    for {\n        msg, err := stream.Recv()\n        if err == io.EOF {\n            return\n        }\n        log.Printf(\"Received: %s\", msg.Content)\n    }\n}()\n\nstream.Send(&#x26;pb.ChatMessage{Content: \"Hello\"})\nstream.Send(&#x26;pb.ChatMessage{Content: \"World\"})\nstream.CloseSend()\n</code></pre>\n<h2>インターセプター</h2>\n<pre><code class=\"language-go\">// 単項インターセプター\nfunc loggingInterceptor(\n    ctx context.Context,\n    req interface{},\n    info *grpc.UnaryServerInfo,\n    handler grpc.UnaryHandler,\n) (interface{}, error) {\n    start := time.Now()\n    resp, err := handler(ctx, req)\n    log.Printf(\"Method: %s, Duration: %v, Error: %v\",\n        info.FullMethod, time.Since(start), err)\n    return resp, err\n}\n\n// ストリームインターセプター\nfunc streamInterceptor(\n    srv interface{},\n    ss grpc.ServerStream,\n    info *grpc.StreamServerInfo,\n    handler grpc.StreamHandler,\n) error {\n    log.Printf(\"Stream started: %s\", info.FullMethod)\n    return handler(srv, ss)\n}\n\n// インターセプター登録\nserver := grpc.NewServer(\n    grpc.UnaryInterceptor(loggingInterceptor),\n    grpc.StreamInterceptor(streamInterceptor),\n)\n</code></pre>\n<h2>エラーハンドリング</h2>\n<pre><code class=\"language-go\">import \"google.golang.org/grpc/codes\"\nimport \"google.golang.org/grpc/status\"\n\n// エラー返却\nfunc (s *server) GetUser(ctx context.Context, req *pb.GetUserRequest) (*pb.GetUserResponse, error) {\n    if req.Id == \"\" {\n        return nil, status.Errorf(codes.InvalidArgument, \"id is required\")\n    }\n\n    user, err := s.db.GetUser(req.Id)\n    if err != nil {\n        if errors.Is(err, sql.ErrNoRows) {\n            return nil, status.Errorf(codes.NotFound, \"user not found\")\n        }\n        return nil, status.Errorf(codes.Internal, \"internal error\")\n    }\n\n    return &#x26;pb.GetUserResponse{User: user}, nil\n}\n\n// エラー処理\nresp, err := client.GetUser(ctx, req)\nif err != nil {\n    st, ok := status.FromError(err)\n    if ok {\n        switch st.Code() {\n        case codes.NotFound:\n            // NotFound 処理\n        case codes.InvalidArgument:\n            // パラメータエラー処理\n        }\n    }\n}\n</code></pre>\n<h2>まとめ</h2>\n<p>gRPC のポイント：</p>\n<ol>\n<li><strong>Protocol Buffers</strong> - 強い型付けインターフェース定義</li>\n<li><strong>高性能</strong> - バイナリシリアライズ + HTTP/2</li>\n<li><strong>ストリーミング</strong> - 4 つの RPC モード</li>\n<li><strong>インターセプター</strong> - 横断的関心事の処理</li>\n<li><strong>コード生成</strong> - 多言語サポート</li>\n</ol>\n"
}