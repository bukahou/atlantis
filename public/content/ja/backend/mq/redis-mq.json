{
  "slug": "redis-mq",
  "meta": {
    "title": "Redis メッセージキュー",
    "description": "Redis によるメッセージキュー実装、Pub/Sub と Stream データ構造",
    "order": 3,
    "tags": [
      "mq",
      "redis",
      "pubsub",
      "stream"
    ]
  },
  "content": "<h1>Redis メッセージキュー</h1>\n<h2>Redis メッセージパターン概要</h2>\n<p>Redis は複数のメッセージキュー実装方式を提供し、様々なシナリオのメッセージング要件に対応します。</p>\n<pre><code>Redis メッセージパターン\n├── List - シンプルキュー (LPUSH/RPOP)\n├── Pub/Sub - パブリッシュ/サブスクライブ\n├── Stream - 永続化メッセージストリーム (推奨)\n└── Sorted Set - 遅延キュー\n</code></pre>\n<h2>List キュー</h2>\n<h3>基本キュー</h3>\n<pre><code class=\"language-go\">import \"github.com/redis/go-redis/v9\"\n\n// プロデューサー - エンキュー\nfunc Produce(rdb *redis.Client, queue string, message string) error {\n    return rdb.LPush(ctx, queue, message).Err()\n}\n\n// コンシューマー - デキュー\nfunc Consume(rdb *redis.Client, queue string) (string, error) {\n    return rdb.RPop(ctx, queue).Result()\n}\n\n// ブロッキング消費\nfunc BlockingConsume(rdb *redis.Client, queue string, timeout time.Duration) (string, error) {\n    result, err := rdb.BRPop(ctx, timeout, queue).Result()\n    if err != nil {\n        return \"\", err\n    }\n    return result[1], nil\n}\n</code></pre>\n<h3>信頼性キュー</h3>\n<pre><code class=\"language-go\">// RPOPLPUSH で信頼性消費を実装\nfunc ReliableConsume(rdb *redis.Client, source, processing string) (string, error) {\n    // 処理キューにアトミック移動\n    return rdb.RPopLPush(ctx, source, processing).Result()\n}\n\n// 完了確認\nfunc Acknowledge(rdb *redis.Client, processing, message string) error {\n    return rdb.LRem(ctx, processing, 1, message).Err()\n}\n\n// 失敗メッセージを再キュー\nfunc Requeue(rdb *redis.Client, processing, source string) error {\n    for {\n        msg, err := rdb.RPopLPush(ctx, processing, source).Result()\n        if err == redis.Nil {\n            break\n        }\n        if err != nil {\n            return err\n        }\n        fmt.Println(\"Requeued:\", msg)\n    }\n    return nil\n}\n</code></pre>\n<h2>Pub/Sub</h2>\n<h3>パブリッシュ/サブスクライブ</h3>\n<pre><code class=\"language-go\">// パブリッシャー\nfunc Publish(rdb *redis.Client, channel, message string) error {\n    return rdb.Publish(ctx, channel, message).Err()\n}\n\n// サブスクライバー\nfunc Subscribe(rdb *redis.Client, channels ...string) {\n    pubsub := rdb.Subscribe(ctx, channels...)\n    defer pubsub.Close()\n\n    // メッセージ受信\n    ch := pubsub.Channel()\n    for msg := range ch {\n        fmt.Printf(\"Channel: %s, Message: %s\\n\", msg.Channel, msg.Payload)\n    }\n}\n\n// パターンサブスクライブ\nfunc PSubscribe(rdb *redis.Client, patterns ...string) {\n    pubsub := rdb.PSubscribe(ctx, patterns...)\n    defer pubsub.Close()\n\n    // order.* パターンをサブスクライブ\n    ch := pubsub.Channel()\n    for msg := range ch {\n        fmt.Printf(\"Pattern: %s, Channel: %s, Message: %s\\n\",\n            msg.Pattern, msg.Channel, msg.Payload)\n    }\n}\n</code></pre>\n<h3>Pub/Sub 制限事項</h3>\n<pre><code>注意事項\n├── 永続化なし - メッセージは送信時に消失\n├── 確認機構なし - 配信保証なし\n├── コンシューマーグループなし - 各サブスクライバーが全メッセージを受信\n└── 適用シナリオ - リアルタイム通知、ブロードキャスト\n</code></pre>\n<h2>Stream (推奨)</h2>\n<h3>Stream 基礎</h3>\n<pre><code class=\"language-go\">// メッセージ追加\nfunc AddMessage(rdb *redis.Client, stream string, values map[string]interface{}) (string, error) {\n    return rdb.XAdd(ctx, &#x26;redis.XAddArgs{\n        Stream: stream,\n        MaxLen: 10000,      // 最大長\n        Approx: true,       // 近似トリミング\n        ID:     \"*\",        // 自動 ID 生成\n        Values: values,\n    }).Result()\n}\n\n// メッセージ読み取り\nfunc ReadMessages(rdb *redis.Client, stream, lastID string, count int64) ([]redis.XMessage, error) {\n    streams, err := rdb.XRead(ctx, &#x26;redis.XReadArgs{\n        Streams: []string{stream, lastID},\n        Count:   count,\n        Block:   0, // ブロッキング待機\n    }).Result()\n\n    if err != nil {\n        return nil, err\n    }\n    return streams[0].Messages, nil\n}\n</code></pre>\n<h3>コンシューマーグループ</h3>\n<pre><code class=\"language-go\">// コンシューマーグループ作成\nfunc CreateGroup(rdb *redis.Client, stream, group string) error {\n    return rdb.XGroupCreateMkStream(ctx, stream, group, \"0\").Err()\n}\n\n// コンシューマーグループ読み取り\nfunc GroupRead(rdb *redis.Client, stream, group, consumer string) ([]redis.XMessage, error) {\n    streams, err := rdb.XReadGroup(ctx, &#x26;redis.XReadGroupArgs{\n        Group:    group,\n        Consumer: consumer,\n        Streams:  []string{stream, \">\"},\n        Count:    10,\n        Block:    5 * time.Second,\n    }).Result()\n\n    if err != nil {\n        return nil, err\n    }\n    if len(streams) == 0 {\n        return nil, nil\n    }\n    return streams[0].Messages, nil\n}\n\n// メッセージ確認\nfunc AckMessage(rdb *redis.Client, stream, group string, ids ...string) error {\n    return rdb.XAck(ctx, stream, group, ids...).Err()\n}\n\n// ペンディングメッセージ取得\nfunc GetPending(rdb *redis.Client, stream, group string) (*redis.XPending, error) {\n    return rdb.XPending(ctx, stream, group).Result()\n}\n\n// タイムアウトメッセージを要求\nfunc ClaimMessages(rdb *redis.Client, stream, group, consumer string, minIdle time.Duration) ([]redis.XMessage, error) {\n    return rdb.XAutoClaim(ctx, &#x26;redis.XAutoClaimArgs{\n        Stream:   stream,\n        Group:    group,\n        Consumer: consumer,\n        MinIdle:  minIdle,\n        Start:    \"0-0\",\n        Count:    10,\n    }).Val(), nil\n}\n</code></pre>\n<h3>完全なコンシューマー例</h3>\n<pre><code class=\"language-go\">type StreamConsumer struct {\n    rdb      *redis.Client\n    stream   string\n    group    string\n    consumer string\n}\n\nfunc (c *StreamConsumer) Run(handler func(msg redis.XMessage) error) {\n    for {\n        // 新しいメッセージを読み取り\n        messages, err := c.rdb.XReadGroup(ctx, &#x26;redis.XReadGroupArgs{\n            Group:    c.group,\n            Consumer: c.consumer,\n            Streams:  []string{c.stream, \">\"},\n            Count:    10,\n            Block:    5 * time.Second,\n        }).Result()\n\n        if err != nil {\n            continue\n        }\n\n        for _, stream := range messages {\n            for _, msg := range stream.Messages {\n                // メッセージ処理\n                if err := handler(msg); err != nil {\n                    // 処理失敗、メッセージは pending に残る\n                    continue\n                }\n                // メッセージ確認\n                c.rdb.XAck(ctx, c.stream, c.group, msg.ID)\n            }\n        }\n    }\n}\n\n// 使用例\nconsumer := &#x26;StreamConsumer{\n    rdb:      rdb,\n    stream:   \"orders\",\n    group:    \"order-processor\",\n    consumer: \"consumer-1\",\n}\n\nconsumer.Run(func(msg redis.XMessage) error {\n    fmt.Printf(\"Processing: %v\\n\", msg.Values)\n    return nil\n})\n</code></pre>\n<h2>遅延キュー</h2>\n<h3>Sorted Set 実装</h3>\n<pre><code class=\"language-go\">// 遅延タスク追加\nfunc AddDelayedTask(rdb *redis.Client, queue, task string, delay time.Duration) error {\n    score := float64(time.Now().Add(delay).Unix())\n    return rdb.ZAdd(ctx, queue, redis.Z{\n        Score:  score,\n        Member: task,\n    }).Err()\n}\n\n// 期限切れタスク取得\nfunc GetDueTasks(rdb *redis.Client, queue string) ([]string, error) {\n    now := float64(time.Now().Unix())\n    return rdb.ZRangeByScore(ctx, queue, &#x26;redis.ZRangeBy{\n        Min: \"-inf\",\n        Max: fmt.Sprintf(\"%f\", now),\n    }).Result()\n}\n\n// 遅延タスク処理\nfunc ProcessDelayedTasks(rdb *redis.Client, queue string) {\n    for {\n        // アトミックに取得して削除\n        result, err := rdb.ZPopMin(ctx, queue, 1).Result()\n        if err != nil || len(result) == 0 {\n            time.Sleep(100 * time.Millisecond)\n            continue\n        }\n\n        task := result[0]\n        score := int64(task.Score)\n\n        // 期限切れチェック\n        if score > time.Now().Unix() {\n            // 未期限、戻す\n            rdb.ZAdd(ctx, queue, task)\n            time.Sleep(100 * time.Millisecond)\n            continue\n        }\n\n        // タスク処理\n        processTask(task.Member.(string))\n    }\n}\n</code></pre>\n<h2>まとめ</h2>\n<p>Redis メッセージキューのポイント：</p>\n<ol>\n<li><strong>List</strong> - シンプルキュー、基本シナリオ向け</li>\n<li><strong>Pub/Sub</strong> - リアルタイムブロードキャスト、永続化なし</li>\n<li><strong>Stream</strong> - 推奨方式、コンシューマーグループサポート</li>\n<li><strong>遅延キュー</strong> - Sorted Set で実装</li>\n<li><strong>選定</strong> - 信頼性と機能要件で選択</li>\n</ol>\n"
}