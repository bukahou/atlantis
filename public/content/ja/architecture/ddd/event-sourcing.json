{
  "slug": "event-sourcing",
  "meta": {
    "title": "イベントソーシング",
    "description": "イベントストアと状態再構築",
    "order": 3,
    "tags": [
      "DDD",
      "イベントソーシング",
      "CQRS"
    ]
  },
  "sections": [
    {
      "type": "keyPoints",
      "title": "コアコンセプト",
      "items": [
        "イベントソーシング：現在の状態ではなくイベントシーケンスでデータを保存",
        "イベントは不変の事実記録",
        "イベントをリプレイして集約状態を再構築",
        "監査追跡とタイムトラベルを自然にサポート"
      ]
    },
    {
      "type": "text",
      "title": "イベントソーシングとは",
      "content": "従来の方式では現在の状態のみを保存し、変更履歴が失われます。イベントソーシングはすべての状態変更イベントを保存し、現在の状態はイベントをリプレイして計算します。銀行口座で例えると、残高だけを保存するのではなく、すべての取引記録を保存し、残高はいつでも計算できます。"
    },
    {
      "type": "comparison",
      "title": "従来のストレージ vs イベントソーシング",
      "columns": [
        {
          "title": "従来のストレージ",
          "color": "from-gray-500 to-slate-500",
          "items": [
            {
              "label": "保存",
              "description": "現在の状態"
            },
            {
              "label": "更新",
              "description": "古い値を上書き"
            },
            {
              "label": "履歴",
              "description": "追加の監査テーブルが必要"
            },
            {
              "label": "デバッグ",
              "description": "問題の追跡が困難"
            }
          ]
        },
        {
          "title": "イベントソーシング",
          "color": "from-blue-500 to-cyan-500",
          "items": [
            {
              "label": "保存",
              "description": "イベントシーケンス"
            },
            {
              "label": "更新",
              "description": "イベントを追加"
            },
            {
              "label": "履歴",
              "description": "完全な監査が自然に含まれる"
            },
            {
              "label": "デバッグ",
              "description": "任意の時点をリプレイ可能"
            }
          ]
        }
      ]
    },
    {
      "type": "codeBlock",
      "title": "イベントソーシング集約の実装",
      "language": "typescript",
      "code": "// ドメインイベント\nabstract class DomainEvent {\n  readonly occurredAt: Date = new Date();\n  abstract readonly eventType: string;\n}\n\nclass AccountCreatedEvent extends DomainEvent {\n  readonly eventType = 'AccountCreated';\n  constructor(\n    public readonly accountId: string,\n    public readonly initialBalance: number\n  ) { super(); }\n}\n\nclass MoneyDepositedEvent extends DomainEvent {\n  readonly eventType = 'MoneyDeposited';\n  constructor(\n    public readonly accountId: string,\n    public readonly amount: number\n  ) { super(); }\n}\n\nclass MoneyWithdrawnEvent extends DomainEvent {\n  readonly eventType = 'MoneyWithdrawn';\n  constructor(\n    public readonly accountId: string,\n    public readonly amount: number\n  ) { super(); }\n}\n\n// イベントソーシング集約\nclass Account {\n  private id: string;\n  private balance: number = 0;\n  private changes: DomainEvent[] = [];\n  \n  // イベントから状態を再構築\n  static fromEvents(events: DomainEvent[]): Account {\n    const account = new Account();\n    events.forEach(e => account.apply(e));\n    return account;\n  }\n  \n  // コマンド：入金\n  deposit(amount: number): void {\n    if (amount <= 0) throw new Error('無効な金額です');\n    this.applyChange(new MoneyDepositedEvent(this.id, amount));\n  }\n  \n  // コマンド：出金\n  withdraw(amount: number): void {\n    if (amount > this.balance) throw new Error('残高不足です');\n    this.applyChange(new MoneyWithdrawnEvent(this.id, amount));\n  }\n  \n  // イベントを適用（状態を更新）\n  private apply(event: DomainEvent): void {\n    if (event instanceof AccountCreatedEvent) {\n      this.id = event.accountId;\n      this.balance = event.initialBalance;\n    } else if (event instanceof MoneyDepositedEvent) {\n      this.balance += event.amount;\n    } else if (event instanceof MoneyWithdrawnEvent) {\n      this.balance -= event.amount;\n    }\n  }\n  \n  // 変更を記録\n  private applyChange(event: DomainEvent): void {\n    this.apply(event);\n    this.changes.push(event);\n  }\n  \n  getUncommittedChanges(): DomainEvent[] {\n    return [...this.changes];\n  }\n}"
    },
    {
      "type": "codeBlock",
      "title": "イベントストア",
      "language": "typescript",
      "code": "// イベントストアインターフェース\ninterface EventStore {\n  // イベントを追加\n  append(\n    streamId: string,\n    events: DomainEvent[],\n    expectedVersion: number\n  ): Promise<void>;\n  \n  // イベントストリームを読み取り\n  readStream(\n    streamId: string,\n    fromVersion?: number\n  ): Promise<DomainEvent[]>;\n}\n\n// リポジトリ実装\nclass AccountRepository {\n  constructor(private eventStore: EventStore) {}\n  \n  async findById(id: string): Promise<Account | null> {\n    const events = await this.eventStore.readStream(`account-${id}`);\n    if (events.length === 0) return null;\n    return Account.fromEvents(events);\n  }\n  \n  async save(account: Account): Promise<void> {\n    const changes = account.getUncommittedChanges();\n    if (changes.length === 0) return;\n    \n    await this.eventStore.append(\n      `account-${account.id}`,\n      changes,\n      account.version  // 楽観的ロック\n    );\n  }\n}\n\n// スナップショット最適化（多数のイベントリプレイを回避）\ninterface Snapshot {\n  version: number;\n  state: any;\n}\n\nasync function loadWithSnapshot(id: string): Promise<Account> {\n  const snapshot = await snapshotStore.get(id);\n  const events = await eventStore.readStream(\n    id,\n    snapshot?.version ?? 0\n  );\n  return Account.fromSnapshot(snapshot, events);\n}"
    },
    {
      "type": "table",
      "title": "適用場面",
      "highlightFirst": true,
      "headers": [
        "場面",
        "適合度",
        "理由"
      ],
      "rows": [
        [
          "厳格な監査要件",
          "非常に適合",
          "完全な履歴が自然に含まれる"
        ],
        [
          "複雑なビジネスロジック",
          "適合",
          "イベント駆動モデリングが明確"
        ],
        [
          "タイムトラベルが必要",
          "非常に適合",
          "任意の時点の状態を再構築可能"
        ],
        [
          "シンプルなCRUD",
          "不適合",
          "過剰設計"
        ],
        [
          "頻繁なクエリ",
          "CQRSとの併用が必要",
          "リプレイのオーバーヘッドが大きい"
        ]
      ]
    },
    {
      "type": "list",
      "title": "注意事項",
      "style": "check",
      "items": [
        {
          "label": "イベントは不変",
          "description": "発行済みイベントは変更不可、新しいイベントで補償のみ"
        },
        {
          "label": "スナップショット最適化",
          "description": "多数のイベントリプレイを避けるため定期的にスナップショットを作成"
        },
        {
          "label": "イベントバージョニング",
          "description": "イベント構造の変更にはバージョンアップグレード戦略が必要"
        },
        {
          "label": "CQRSとの併用",
          "description": "読み取りモデルはプロジェクションでクエリ性能を最適化"
        }
      ]
    }
  ],
  "relatedTopics": [
    "CQRS",
    "ドメインイベント",
    "監査ログ"
  ]
}