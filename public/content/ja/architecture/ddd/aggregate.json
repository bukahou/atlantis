{
  "slug": "aggregate",
  "meta": {
    "title": "集約ルート",
    "description": "集約設計の原則と整合性の保証",
    "order": 2,
    "tags": [
      "DDD",
      "集約",
      "整合性"
    ]
  },
  "sections": [
    {
      "type": "keyPoints",
      "title": "コアコンセプト",
      "items": [
        "集約は関連オブジェクトの集合で、データ変更の単位として機能",
        "集約ルートは集約のエントリポイント、外部は集約ルートのみを参照可能",
        "集約内は強整合性を保証、集約間は結果整合性を保証",
        "集約境界はトランザクション境界でもある"
      ]
    },
    {
      "type": "text",
      "title": "なぜ集約が必要か",
      "content": "複雑なドメインモデルでは、オブジェクト間に多くの関連が存在します。任意のオブジェクト間で直接参照や変更を許可すると、データの不整合やメンテナンス困難を招きます。集約は境界を定めることで、オブジェクトのアクセスと変更ルールを制御し、データ整合性を保証します。"
    },
    {
      "type": "codeBlock",
      "title": "注文集約の例",
      "language": "typescript",
      "code": "// 集約ルート：Order\nclass Order {\n  private readonly id: OrderId;\n  private items: OrderItem[] = [];\n  private status: OrderStatus;\n  private totalAmount: Money;\n  \n  // 集約ルートを通じてのみ内部オブジェクトを変更可能\n  addItem(product: ProductSnapshot, quantity: number): void {\n    // ビジネスルール検証\n    if (this.status !== OrderStatus.Draft) {\n      throw new Error('確定済み注文は変更できません');\n    }\n    if (quantity <= 0) {\n      throw new Error('無効な数量です');\n    }\n    \n    // 注文明細を追加\n    const item = new OrderItem(product, quantity);\n    this.items.push(item);\n    \n    // 合計金額を再計算（整合性を保証）\n    this.recalculateTotal();\n  }\n  \n  removeItem(itemId: OrderItemId): void {\n    this.items = this.items.filter(i => !i.id.equals(itemId));\n    this.recalculateTotal();\n  }\n  \n  confirm(): void {\n    if (this.items.length === 0) {\n      throw new Error('空の注文は確定できません');\n    }\n    this.status = OrderStatus.Confirmed;\n    \n    // ドメインイベントを発行\n    this.addDomainEvent(new OrderConfirmedEvent(this.id));\n  }\n  \n  private recalculateTotal(): void {\n    this.totalAmount = this.items.reduce(\n      (sum, item) => sum.add(item.subtotal),\n      Money.zero()\n    );\n  }\n}\n\n// 値オブジェクト：OrderItem（独立して存在できない）\nclass OrderItem {\n  readonly id: OrderItemId;\n  readonly productSnapshot: ProductSnapshot;\n  readonly quantity: number;\n  readonly unitPrice: Money;\n  \n  get subtotal(): Money {\n    return this.unitPrice.multiply(this.quantity);\n  }\n}"
    },
    {
      "type": "cards",
      "title": "集約設計の原則",
      "layout": "grid",
      "columns": 2,
      "items": [
        {
          "title": "小さな集約",
          "badge": "原則1",
          "badgeColor": "blue",
          "points": [
            "集約は可能な限り小さく",
            "必ず一緒に変更すべきオブジェクトのみ含む",
            "大きな集約は並行競合を招く"
          ]
        },
        {
          "title": "ID参照",
          "badge": "原則2",
          "badgeColor": "green",
          "points": [
            "集約間はID参照",
            "オブジェクト参照を直接保持しない",
            "境界を明確に保つ"
          ]
        }
      ]
    },
    {
      "type": "codeBlock",
      "title": "集約間のコラボレーション",
      "language": "typescript",
      "code": "// 誤り：集約間の直接参照\nclass Order {\n  customer: Customer;  // ❌ 別の集約を直接参照\n}\n\n// 正解：ID参照\nclass Order {\n  customerId: CustomerId;  // ✅ IDのみを保持\n}\n\n// Customer情報が必要な場合、アプリケーションサービスを通じて取得\nclass OrderApplicationService {\n  async createOrder(command: CreateOrderCommand): Promise<OrderId> {\n    // 顧客情報を取得\n    const customer = await this.customerRepository.findById(command.customerId);\n    if (!customer) {\n      throw new CustomerNotFoundError();\n    }\n    \n    // 注文を作成（必要な情報のみ渡す）\n    const order = Order.create({\n      customerId: customer.id,\n      shippingAddress: customer.defaultAddress,  // スナップショット\n    });\n    \n    await this.orderRepository.save(order);\n    return order.id;\n  }\n}"
    },
    {
      "type": "table",
      "title": "集約 vs エンティティ vs 値オブジェクト",
      "highlightFirst": true,
      "headers": [
        "概念",
        "識別子",
        "可変性",
        "ライフサイクル"
      ],
      "rows": [
        [
          "集約ルート",
          "一意の識別子あり",
          "可変",
          "独立したライフサイクル"
        ],
        [
          "エンティティ",
          "一意の識別子あり",
          "可変",
          "集約に依存"
        ],
        [
          "値オブジェクト",
          "識別子なし（値の等価性）",
          "不変",
          "置換可能"
        ]
      ]
    },
    {
      "type": "list",
      "title": "設計チェックリスト",
      "style": "check",
      "items": [
        {
          "label": "ビジネス不変条件",
          "description": "集約境界は必ず一緒に変化すべきデータを含む"
        },
        {
          "label": "トランザクション境界",
          "description": "1つのトランザクションで1つの集約のみ変更"
        },
        {
          "label": "結果整合性",
          "description": "集約間はドメインイベントで結果整合性を維持"
        },
        {
          "label": "並行制御",
          "description": "楽観的ロック（バージョン番号）で並行処理"
        }
      ]
    }
  ],
  "relatedTopics": [
    "エンティティ",
    "値オブジェクト",
    "ドメインイベント"
  ]
}