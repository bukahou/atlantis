{
  "slug": "redis",
  "meta": {
    "title": "Redis",
    "description": "Redis インメモリデータベース、データ構造とキャッシュ戦略",
    "order": 2,
    "tags": [
      "database",
      "redis",
      "nosql",
      "cache"
    ]
  },
  "content": "<h1>Redis</h1>\n<h2>Redis 概要</h2>\n<p>Redis は高性能インメモリキーバリューデータベースで、豊富なデータ構造をサポートし、キャッシュ、セッションストレージ、リアルタイムアプリケーションで広く使用されています。</p>\n<pre><code>Redis 特性\n├── インメモリストレージ - 極めて高性能\n├── 豊富なデータ構造 - String, Hash, List, Set, ZSet\n├── 永続化 - RDB, AOF\n├── クラスター - マスタースレーブ, Sentinel, Cluster\n├── トランザクション - MULTI/EXEC\n└── Lua スクリプト - アトミック操作\n</code></pre>\n<h2>データ構造</h2>\n<h3>String</h3>\n<pre><code class=\"language-redis\"># 基本操作\nSET key value\nGET key\nDEL key\n\n# 有効期限\nSET key value EX 3600\nSETEX key 3600 value\nTTL key\n\n# 数値操作\nINCR counter\nINCRBY counter 10\nDECR counter\n\n# バルク操作\nMSET k1 v1 k2 v2\nMGET k1 k2\n</code></pre>\n<h3>Hash</h3>\n<pre><code class=\"language-redis\"># ハッシュ操作\nHSET user:1 name \"Alice\" age 28\nHGET user:1 name\nHGETALL user:1\nHDEL user:1 age\n\n# バルク操作\nHMSET user:1 name \"Alice\" email \"alice@example.com\"\nHMGET user:1 name email\n\n# 数値操作\nHINCRBY user:1 age 1\n</code></pre>\n<h3>List</h3>\n<pre><code class=\"language-redis\"># リスト操作\nLPUSH queue item1 item2\nRPUSH queue item3\nLPOP queue\nRPOP queue\n\n# ブロッキング操作\nBLPOP queue 10\nBRPOP queue 10\n\n# 範囲クエリ\nLRANGE queue 0 -1\nLLEN queue\n</code></pre>\n<h3>Set</h3>\n<pre><code class=\"language-redis\"># セット操作\nSADD tags golang python rust\nSMEMBERS tags\nSISMEMBER tags golang\nSREM tags python\n\n# セット演算\nSINTER set1 set2       # 積集合\nSUNION set1 set2       # 和集合\nSDIFF set1 set2        # 差集合\n</code></pre>\n<h3>Sorted Set</h3>\n<pre><code class=\"language-redis\"># ソート済みセット\nZADD leaderboard 100 \"player1\" 200 \"player2\"\nZSCORE leaderboard player1\nZRANK leaderboard player1\n\n# 範囲クエリ\nZRANGE leaderboard 0 -1 WITHSCORES\nZREVRANGE leaderboard 0 9 WITHSCORES\nZRANGEBYSCORE leaderboard 100 200\n\n# スコア更新\nZINCRBY leaderboard 50 player1\n</code></pre>\n<h2>Go クライアント</h2>\n<pre><code class=\"language-go\">import \"github.com/redis/go-redis/v9\"\n\n// 接続\nrdb := redis.NewClient(&#x26;redis.Options{\n    Addr:     \"localhost:6379\",\n    Password: \"\",\n    DB:       0,\n})\n\n// String\nrdb.Set(ctx, \"key\", \"value\", time.Hour).Err()\nval, _ := rdb.Get(ctx, \"key\").Result()\n\n// Hash\nrdb.HSet(ctx, \"user:1\", \"name\", \"Alice\", \"age\", 28)\nrdb.HGetAll(ctx, \"user:1\").Result()\n\n// List\nrdb.LPush(ctx, \"queue\", \"item1\", \"item2\")\nrdb.BRPop(ctx, 0, \"queue\").Result()\n\n// Set\nrdb.SAdd(ctx, \"tags\", \"golang\", \"redis\")\nrdb.SMembers(ctx, \"tags\").Result()\n\n// Sorted Set\nrdb.ZAdd(ctx, \"scores\", redis.Z{Score: 100, Member: \"player1\"})\nrdb.ZRevRangeWithScores(ctx, \"scores\", 0, 9).Result()\n\n// Pipeline\npipe := rdb.Pipeline()\npipe.Set(ctx, \"k1\", \"v1\", 0)\npipe.Set(ctx, \"k2\", \"v2\", 0)\npipe.Exec(ctx)\n</code></pre>\n<h2>キャッシュ戦略</h2>\n<h3>キャッシュパターン</h3>\n<pre><code class=\"language-go\">// Cache Aside\nfunc GetUser(id string) (*User, error) {\n    // 1. キャッシュ確認\n    cached, err := rdb.Get(ctx, \"user:\"+id).Result()\n    if err == nil {\n        return unmarshal(cached), nil\n    }\n\n    // 2. データベース確認\n    user, err := db.GetUser(id)\n    if err != nil {\n        return nil, err\n    }\n\n    // 3. キャッシュ書き込み\n    rdb.Set(ctx, \"user:\"+id, marshal(user), time.Hour)\n    return user, nil\n}\n\n// Write Through\nfunc UpdateUser(user *User) error {\n    // 1. データベース更新\n    if err := db.UpdateUser(user); err != nil {\n        return err\n    }\n\n    // 2. キャッシュ更新\n    return rdb.Set(ctx, \"user:\"+user.ID, marshal(user), time.Hour).Err()\n}\n</code></pre>\n<h3>キャッシュ問題</h3>\n<pre><code class=\"language-go\">// キャッシュ穿通 - 存在しないデータへのクエリ\n// 解決: ブルームフィルター / 空値キャッシュ\nfunc GetWithBloomFilter(id string) (*User, error) {\n    if !bloomFilter.Contains(id) {\n        return nil, ErrNotFound\n    }\n    // クエリ続行\n}\n\n// キャッシュ突破 - ホットキー期限切れ\n// 解決: ミューテックス / 論理期限切れ\nfunc GetWithMutex(id string) (*User, error) {\n    // ロック取得\n    lockKey := \"lock:user:\" + id\n    if ok, _ := rdb.SetNX(ctx, lockKey, 1, time.Second*10).Result(); !ok {\n        time.Sleep(50 * time.Millisecond)\n        return GetWithMutex(id)\n    }\n    defer rdb.Del(ctx, lockKey)\n\n    // クエリしてキャッシュ\n    return fetchAndCache(id)\n}\n\n// キャッシュ雪崩 - 大量のキーが同時期限切れ\n// 解決: 有効期限にランダム値を追加\nfunc SetWithRandomExpire(key string, value interface{}) error {\n    expire := time.Hour + time.Duration(rand.Intn(300))*time.Second\n    return rdb.Set(ctx, key, value, expire).Err()\n}\n</code></pre>\n<h2>分散ロック</h2>\n<pre><code class=\"language-go\">// ロック取得\nfunc Lock(key string, value string, expire time.Duration) bool {\n    return rdb.SetNX(ctx, key, value, expire).Val()\n}\n\n// ロック解放 (Lua スクリプトでアトミック性保証)\nvar unlockScript = redis.NewScript(`\n    if redis.call(\"get\", KEYS[1]) == ARGV[1] then\n        return redis.call(\"del\", KEYS[1])\n    else\n        return 0\n    end\n`)\n\nfunc Unlock(key string, value string) bool {\n    result, _ := unlockScript.Run(ctx, rdb, []string{key}, value).Int()\n    return result == 1\n}\n\n// Redlock アルゴリズム (マルチノード)\n// 1. 現在時刻取得\n// 2. N ノードに順次ロック要求\n// 3. 過半数のノードで取得成功かつタイムアウトなしでロック成功\n// 4. ロック有効時間 = 初期有効時間 - ロック取得時間\n</code></pre>\n<h2>永続化</h2>\n<pre><code class=\"language-yaml\"># RDB スナップショット\nsave 900 1      # 900秒以内に1回以上の変更\nsave 300 10     # 300秒以内に10回以上の変更\nsave 60 10000   # 60秒以内に10000回以上の変更\n\n# AOF ログ\nappendonly yes\nappendfsync everysec  # 毎秒同期\n\n# ハイブリッド永続化 (推奨)\naof-use-rdb-preamble yes\n</code></pre>\n<h2>クラスター</h2>\n<pre><code class=\"language-yaml\"># マスタースレーブレプリケーション\nslaveof 192.168.1.1 6379\n\n# Sentinel モード\nsentinel monitor mymaster 192.168.1.1 6379 2\nsentinel down-after-milliseconds mymaster 30000\nsentinel failover-timeout mymaster 180000\n\n# Cluster モード\ncluster-enabled yes\ncluster-config-file nodes.conf\ncluster-node-timeout 15000\n</code></pre>\n<h2>まとめ</h2>\n<p>Redis のポイント：</p>\n<ol>\n<li><strong>データ構造</strong> - String, Hash, List, Set, ZSet</li>\n<li><strong>キャッシュ戦略</strong> - Cache Aside, 穿通/突破/雪崩</li>\n<li><strong>分散ロック</strong> - SETNX, Lua スクリプト</li>\n<li><strong>永続化</strong> - RDB + AOF ハイブリッド</li>\n<li><strong>高可用性</strong> - マスタースレーブ, Sentinel, Cluster</li>\n</ol>\n"
}