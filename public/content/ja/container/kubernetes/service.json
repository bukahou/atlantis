{
  "slug": "service",
  "meta": {
    "title": "Kubernetes Service 詳解",
    "description": "Service タイプ、サービスディスカバリと負荷分散設定",
    "order": 2,
    "tags": [
      "kubernetes",
      "service",
      "networking",
      "load-balancer"
    ]
  },
  "content": "<h1>Kubernetes Service 詳解</h1>\n<h2>Service の概念</h2>\n<p>Service は Kubernetes において Pod グループへのアクセスポリシーを定義する抽象で、安定したネットワークエンドポイントと負荷分散を提供します。</p>\n<pre><code>Service 動作原理\n                      ┌─────────────────┐\n                      │     Service     │\n                      │  ClusterIP:     │\n                      │  10.96.100.1    │\n                      └────────┬────────┘\n                               │\n              ┌────────────────┼────────────────┐\n              │                │                │\n        ┌─────▼─────┐   ┌─────▼─────┐   ┌─────▼─────┐\n        │   Pod 1   │   │   Pod 2   │   │   Pod 3   │\n        │ 10.244.1.5│   │ 10.244.2.3│   │ 10.244.3.7│\n        │  app:web  │   │  app:web  │   │  app:web  │\n        └───────────┘   └───────────┘   └───────────┘\n</code></pre>\n<h2>Service タイプ</h2>\n<h3>ClusterIP (デフォルト)</h3>\n<p>クラスタ内部アクセス、外部には公開しない。</p>\n<pre><code class=\"language-yaml\">apiVersion: v1\nkind: Service\nmetadata:\n  name: webapp-service\nspec:\n  type: ClusterIP  # デフォルトタイプ\n  selector:\n    app: webapp\n  ports:\n    - name: http\n      port: 80        # Service ポート\n      targetPort: 8080 # Pod ポート\n      protocol: TCP\n</code></pre>\n<h3>NodePort</h3>\n<p>ノードポートを通じて外部にサービスを公開。</p>\n<pre><code class=\"language-yaml\">apiVersion: v1\nkind: Service\nmetadata:\n  name: webapp-nodeport\nspec:\n  type: NodePort\n  selector:\n    app: webapp\n  ports:\n    - name: http\n      port: 80\n      targetPort: 8080\n      nodePort: 30080  # 範囲: 30000-32767\n</code></pre>\n<pre><code>NodePort アクセスフロー\n外部リクエスト → NodeIP:30080 → Service:80 → Pod:8080\n\n任意のノード IP + NodePort でアクセス可能\n</code></pre>\n<h3>LoadBalancer</h3>\n<p>クラウドプロバイダーのロードバランサーを使用。</p>\n<pre><code class=\"language-yaml\">apiVersion: v1\nkind: Service\nmetadata:\n  name: webapp-lb\n  annotations:\n    # AWS アノテーション\n    service.beta.kubernetes.io/aws-load-balancer-type: nlb\n    service.beta.kubernetes.io/aws-load-balancer-internal: \"true\"\nspec:\n  type: LoadBalancer\n  selector:\n    app: webapp\n  ports:\n    - name: http\n      port: 80\n      targetPort: 8080\n  loadBalancerSourceRanges:\n    - 10.0.0.0/8\n    - 192.168.0.0/16\n</code></pre>\n<h3>ExternalName</h3>\n<p>サービスを外部 DNS 名にマッピング。</p>\n<pre><code class=\"language-yaml\">apiVersion: v1\nkind: Service\nmetadata:\n  name: external-db\nspec:\n  type: ExternalName\n  externalName: db.example.com\n</code></pre>\n<h2>Headless Service</h2>\n<p>ClusterIP を割り当てず、Pod IP を直接返す。</p>\n<pre><code class=\"language-yaml\">apiVersion: v1\nkind: Service\nmetadata:\n  name: webapp-headless\nspec:\n  clusterIP: None  # Headless\n  selector:\n    app: webapp\n  ports:\n    - port: 80\n      targetPort: 8080\n</code></pre>\n<pre><code class=\"language-bash\"># DNS クエリはすべての Pod IP を返す\nnslookup webapp-headless.default.svc.cluster.local\n# → 10.244.1.5\n# → 10.244.2.3\n# → 10.244.3.7\n</code></pre>\n<h3>StatefulSet との組み合わせ</h3>\n<pre><code class=\"language-yaml\">apiVersion: v1\nkind: Service\nmetadata:\n  name: mysql\nspec:\n  clusterIP: None\n  selector:\n    app: mysql\n  ports:\n    - port: 3306\n---\napiVersion: apps/v1\nkind: StatefulSet\nmetadata:\n  name: mysql\nspec:\n  serviceName: mysql  # Headless Service と関連付け\n  replicas: 3\n  selector:\n    matchLabels:\n      app: mysql\n  template:\n    metadata:\n      labels:\n        app: mysql\n    spec:\n      containers:\n        - name: mysql\n          image: mysql:8.0\n</code></pre>\n<pre><code class=\"language-bash\"># 安定した DNS 名で特定の Pod にアクセス可能\nmysql-0.mysql.default.svc.cluster.local\nmysql-1.mysql.default.svc.cluster.local\nmysql-2.mysql.default.svc.cluster.local\n</code></pre>\n<h2>サービスディスカバリ</h2>\n<h3>DNS 解決</h3>\n<pre><code>Service DNS 形式\n├── &#x3C;service>.&#x3C;namespace>.svc.cluster.local (完全)\n├── &#x3C;service>.&#x3C;namespace>.svc\n├── &#x3C;service>.&#x3C;namespace>\n└── &#x3C;service> (同じ namespace)\n</code></pre>\n<pre><code class=\"language-yaml\"># アプリケーションでの DNS 使用\nenv:\n  - name: DB_HOST\n    value: \"mysql.database.svc.cluster.local\"\n  - name: CACHE_HOST\n    value: \"redis.cache\"  # 短縮形\n</code></pre>\n<h2>マルチポート Service</h2>\n<pre><code class=\"language-yaml\">apiVersion: v1\nkind: Service\nmetadata:\n  name: webapp\nspec:\n  selector:\n    app: webapp\n  ports:\n    - name: http\n      port: 80\n      targetPort: 8080\n    - name: https\n      port: 443\n      targetPort: 8443\n    - name: metrics\n      port: 9090\n      targetPort: 9090\n</code></pre>\n<h2>Session Affinity</h2>\n<p>クライアントリクエストを同じ Pod に維持。</p>\n<pre><code class=\"language-yaml\">apiVersion: v1\nkind: Service\nmetadata:\n  name: webapp\nspec:\n  selector:\n    app: webapp\n  sessionAffinity: ClientIP\n  sessionAffinityConfig:\n    clientIP:\n      timeoutSeconds: 3600  # 1時間\n  ports:\n    - port: 80\n      targetPort: 8080\n</code></pre>\n<h2>Ingress との比較</h2>\n<pre><code>Service vs Ingress\n\nService (L4):\n├── NodePort: Node IP + ポート\n├── LoadBalancer: クラウドロードバランサー\n└── サービスごとに1つの外部 IP\n\nIngress (L7):\n├── 単一のエントリーポイント\n├── Host/Path ベースのルーティング\n├── SSL 終端\n└── 複数サービスで1つの IP を共有\n</code></pre>\n<pre><code class=\"language-yaml\"># Ingress の例\napiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: webapp-ingress\nspec:\n  ingressClassName: nginx\n  tls:\n    - hosts:\n        - example.com\n      secretName: tls-secret\n  rules:\n    - host: example.com\n      http:\n        paths:\n          - path: /api\n            pathType: Prefix\n            backend:\n              service:\n                name: api-service\n                port:\n                  number: 80\n          - path: /\n            pathType: Prefix\n            backend:\n              service:\n                name: frontend-service\n                port:\n                  number: 80\n</code></pre>\n<h2>トラフィックポリシー</h2>\n<pre><code class=\"language-yaml\">apiVersion: v1\nkind: Service\nmetadata:\n  name: webapp\nspec:\n  selector:\n    app: webapp\n  ports:\n    - port: 80\n  # 内部トラフィックポリシー\n  internalTrafficPolicy: Local  # ローカル Pod を優先\n  # 外部トラフィックポリシー (NodePort/LoadBalancer)\n  externalTrafficPolicy: Local  # クライアント IP を保持\n</code></pre>\n<h2>よく使うコマンド</h2>\n<pre><code class=\"language-bash\"># Service の確認\nkubectl get svc\nkubectl get svc -o wide\nkubectl describe svc webapp\n\n# Endpoints の確認\nkubectl get endpoints webapp\n\n# サービス接続性のテスト\nkubectl run test --rm -it --image=busybox -- wget -qO- http://webapp\n\n# ポートフォワード\nkubectl port-forward svc/webapp 8080:80\n\n# Deployment を Service として公開\nkubectl expose deployment webapp --port=80 --target-port=8080\n\n# Service の削除\nkubectl delete svc webapp\n</code></pre>\n<h2>ベストプラクティス</h2>\n<ol>\n<li><strong>意味のある名前を使用</strong> - 名前が DNS になるため、簡潔に</li>\n<li><strong>ポート名を定義</strong> - Istio などがプロトコルを識別しやすく</li>\n<li><strong>Headless を使用</strong> - StatefulSet とサービスディスカバリに</li>\n<li><strong>ヘルスチェックを設定</strong> - 健全な Pod のみにルーティング</li>\n<li><strong>トラフィックポリシーを考慮</strong> - 要件に応じて Local/Cluster を選択</li>\n<li><strong>Ingress を使用</strong> - 複数サービスで入口を共有</li>\n<li><strong>ExternalName を適切に使用</strong> - 外部依存を抽象化</li>\n</ol>\n"
}