{
  "slug": "composition",
  "meta": {
    "title": "Vue Composition API",
    "description": "Vue 3 Composition API コア概念とリアクティブシステム",
    "order": 1,
    "tags": [
      "vue",
      "composition",
      "frontend",
      "reactive"
    ]
  },
  "content": "<h1>Vue Composition API</h1>\n<h2>Composition API 概要</h2>\n<p>Vue 3 の Composition API は、コンポーネントロジックを整理するより柔軟な方法を提供し、ロジックの再利用とコード構成を容易にします。</p>\n<pre><code>Composition API コア\n├── ref / reactive - リアクティブデータ\n├── computed - 算出プロパティ\n├── watch / watchEffect - ウォッチャー\n├── ライフサイクルフック - onMounted など\n└── 依存性注入 - provide / inject\n</code></pre>\n<h2>リアクティブ基礎</h2>\n<h3>ref</h3>\n<pre><code class=\"language-vue\">&#x3C;script setup lang=\"ts\">\nimport { ref } from \"vue\";\n\n// プリミティブ型\nconst count = ref(0);\nconst name = ref(\"Vue\");\n\n// アクセスと変更\nconsole.log(count.value);\ncount.value++;\n\n// 型推論\nconst message = ref(\"Hello\");  // Ref&#x3C;string>\n\n// 明示的な型\nconst user = ref&#x3C;User | null>(null);\n&#x3C;/script>\n\n&#x3C;template>\n  &#x3C;!-- テンプレートで自動アンラップ -->\n  &#x3C;div>{{ count }}&#x3C;/div>\n  &#x3C;button @click=\"count++\">+1&#x3C;/button>\n&#x3C;/template>\n</code></pre>\n<h3>reactive</h3>\n<pre><code class=\"language-vue\">&#x3C;script setup lang=\"ts\">\nimport { reactive } from \"vue\";\n\n// オブジェクトのリアクティブ化\nconst state = reactive({\n  count: 0,\n  user: {\n    name: \"Alice\",\n    age: 30,\n  },\n  items: [] as string[],\n});\n\n// 直接変更\nstate.count++;\nstate.user.name = \"Bob\";\nstate.items.push(\"item\");\n\n// 型定義\ninterface State {\n  count: number;\n  user: User;\n  items: string[];\n}\n\nconst typedState = reactive&#x3C;State>({\n  count: 0,\n  user: { name: \"\", age: 0 },\n  items: [],\n});\n&#x3C;/script>\n</code></pre>\n<h3>ref vs reactive</h3>\n<pre><code class=\"language-vue\">&#x3C;script setup lang=\"ts\">\nimport { ref, reactive, toRefs } from \"vue\";\n\n// ref - プリミティブ型向け、.value が必要\nconst count = ref(0);\ncount.value++;\n\n// reactive - オブジェクト向け、.value 不要\nconst state = reactive({ count: 0 });\nstate.count++;\n\n// toRefs - リアクティブオブジェクトの分割\nconst { count: countRef } = toRefs(state);\n\n// shallowRef - 浅いリアクティブ\nconst shallowState = shallowRef({ nested: { value: 1 } });\n// shallowState.value の置換のみ更新をトリガー\n&#x3C;/script>\n</code></pre>\n<h2>算出プロパティ</h2>\n<pre><code class=\"language-vue\">&#x3C;script setup lang=\"ts\">\nimport { ref, computed } from \"vue\";\n\nconst firstName = ref(\"John\");\nconst lastName = ref(\"Doe\");\n\n// 読み取り専用算出プロパティ\nconst fullName = computed(() => {\n  return `${firstName.value} ${lastName.value}`;\n});\n\n// 書き込み可能算出プロパティ\nconst fullNameWritable = computed({\n  get() {\n    return `${firstName.value} ${lastName.value}`;\n  },\n  set(newValue: string) {\n    const parts = newValue.split(\" \");\n    firstName.value = parts[0];\n    lastName.value = parts[1] || \"\";\n  },\n});\n\nfullNameWritable.value = \"Jane Smith\";\n&#x3C;/script>\n</code></pre>\n<h2>ウォッチャー</h2>\n<h3>watch</h3>\n<pre><code class=\"language-vue\">&#x3C;script setup lang=\"ts\">\nimport { ref, watch } from \"vue\";\n\nconst count = ref(0);\nconst user = ref({ name: \"Alice\", age: 30 });\n\n// 単一の ref を監視\nwatch(count, (newValue, oldValue) => {\n  console.log(`Count: ${oldValue} -> ${newValue}`);\n});\n\n// 複数のソースを監視\nwatch([count, () => user.value.name], ([newCount, newName], [oldCount, oldName]) => {\n  console.log(`Count: ${oldCount} -> ${newCount}`);\n  console.log(`Name: ${oldName} -> ${newName}`);\n});\n\n// 深い監視\nwatch(\n  user,\n  (newValue) => {\n    console.log(\"User changed:\", newValue);\n  },\n  { deep: true }\n);\n\n// 即時実行\nwatch(\n  count,\n  (value) => {\n    console.log(\"Count:\", value);\n  },\n  { immediate: true }\n);\n\n// 一回限り\nwatch(\n  count,\n  () => {\n    console.log(\"Triggered once\");\n  },\n  { once: true }\n);\n&#x3C;/script>\n</code></pre>\n<h3>watchEffect</h3>\n<pre><code class=\"language-vue\">&#x3C;script setup lang=\"ts\">\nimport { ref, watchEffect } from \"vue\";\n\nconst count = ref(0);\nconst name = ref(\"Vue\");\n\n// 自動的に依存関係を追跡\nwatchEffect(() => {\n  console.log(`Count: ${count.value}, Name: ${name.value}`);\n});\n\n// 副作用のクリーンアップ\nwatchEffect((onCleanup) => {\n  const timer = setInterval(() => {\n    count.value++;\n  }, 1000);\n\n  onCleanup(() => {\n    clearInterval(timer);\n  });\n});\n\n// 監視を停止\nconst stop = watchEffect(() => {\n  console.log(count.value);\n});\n\nstop();  // 停止\n\n// フラッシュタイミング\nwatchEffect(\n  () => {\n    // DOM 更新後に実行\n  },\n  { flush: \"post\" }\n);\n&#x3C;/script>\n</code></pre>\n<h2>ライフサイクル</h2>\n<pre><code class=\"language-vue\">&#x3C;script setup lang=\"ts\">\nimport {\n  onBeforeMount,\n  onMounted,\n  onBeforeUpdate,\n  onUpdated,\n  onBeforeUnmount,\n  onUnmounted,\n  onErrorCaptured,\n} from \"vue\";\n\nonBeforeMount(() => {\n  console.log(\"Before mount\");\n});\n\nonMounted(() => {\n  console.log(\"Mounted\");\n  // DOM にアクセス\n});\n\nonBeforeUpdate(() => {\n  console.log(\"Before update\");\n});\n\nonUpdated(() => {\n  console.log(\"Updated\");\n});\n\nonBeforeUnmount(() => {\n  console.log(\"Before unmount\");\n});\n\nonUnmounted(() => {\n  console.log(\"Unmounted\");\n  // クリーンアップ\n});\n\nonErrorCaptured((error, instance, info) => {\n  console.error(\"Error captured:\", error);\n  return false;  // エラーの伝播を防ぐ\n});\n&#x3C;/script>\n</code></pre>\n<h2>テンプレート参照</h2>\n<pre><code class=\"language-vue\">&#x3C;script setup lang=\"ts\">\nimport { ref, onMounted } from \"vue\";\n\n// DOM 参照\nconst inputRef = ref&#x3C;HTMLInputElement | null>(null);\n\n// コンポーネント参照\nconst childRef = ref&#x3C;InstanceType&#x3C;typeof ChildComponent> | null>(null);\n\nonMounted(() => {\n  inputRef.value?.focus();\n  childRef.value?.someMethod();\n});\n&#x3C;/script>\n\n&#x3C;template>\n  &#x3C;input ref=\"inputRef\" />\n  &#x3C;ChildComponent ref=\"childRef\" />\n&#x3C;/template>\n</code></pre>\n<h2>依存性注入</h2>\n<pre><code class=\"language-vue\">&#x3C;!-- 親コンポーネント -->\n&#x3C;script setup lang=\"ts\">\nimport { provide, ref } from \"vue\";\n\nconst theme = ref(\"dark\");\nconst updateTheme = (newTheme: string) => {\n  theme.value = newTheme;\n};\n\n// リアクティブデータを提供\nprovide(\"theme\", theme);\nprovide(\"updateTheme\", updateTheme);\n\n// Symbol をキーとして使用\nconst ThemeSymbol = Symbol(\"theme\");\nprovide(ThemeSymbol, { theme, updateTheme });\n&#x3C;/script>\n\n&#x3C;!-- 子コンポーネント -->\n&#x3C;script setup lang=\"ts\">\nimport { inject, type Ref } from \"vue\";\n\n// データを注入\nconst theme = inject&#x3C;Ref&#x3C;string>>(\"theme\");\nconst updateTheme = inject&#x3C;(theme: string) => void>(\"updateTheme\");\n\n// デフォルト値\nconst theme2 = inject(\"theme\", ref(\"light\"));\n\n// Symbol を使用\nconst ThemeSymbol = Symbol(\"theme\");\nconst themeContext = inject(ThemeSymbol);\n&#x3C;/script>\n</code></pre>\n<h2>コンポーザブル (Composables)</h2>\n<pre><code class=\"language-typescript\">// composables/useMouse.ts\nimport { ref, onMounted, onUnmounted } from \"vue\";\n\nexport function useMouse() {\n  const x = ref(0);\n  const y = ref(0);\n\n  function update(event: MouseEvent) {\n    x.value = event.pageX;\n    y.value = event.pageY;\n  }\n\n  onMounted(() => window.addEventListener(\"mousemove\", update));\n  onUnmounted(() => window.removeEventListener(\"mousemove\", update));\n\n  return { x, y };\n}\n\n// composables/useFetch.ts\nimport { ref, watchEffect } from \"vue\";\n\nexport function useFetch&#x3C;T>(url: string) {\n  const data = ref&#x3C;T | null>(null);\n  const error = ref&#x3C;Error | null>(null);\n  const loading = ref(true);\n\n  watchEffect(async () => {\n    loading.value = true;\n    error.value = null;\n\n    try {\n      const response = await fetch(url);\n      data.value = await response.json();\n    } catch (e) {\n      error.value = e instanceof Error ? e : new Error(\"Unknown error\");\n    } finally {\n      loading.value = false;\n    }\n  });\n\n  return { data, error, loading };\n}\n</code></pre>\n<pre><code class=\"language-vue\">&#x3C;!-- コンポーザブルの使用 -->\n&#x3C;script setup lang=\"ts\">\nimport { useMouse } from \"@/composables/useMouse\";\nimport { useFetch } from \"@/composables/useFetch\";\n\nconst { x, y } = useMouse();\nconst { data, loading, error } = useFetch&#x3C;User[]>(\"/api/users\");\n&#x3C;/script>\n\n&#x3C;template>\n  &#x3C;div>Mouse: {{ x }}, {{ y }}&#x3C;/div>\n  &#x3C;div v-if=\"loading\">Loading...&#x3C;/div>\n  &#x3C;div v-else-if=\"error\">{{ error.message }}&#x3C;/div>\n  &#x3C;ul v-else>\n    &#x3C;li v-for=\"user in data\" :key=\"user.id\">{{ user.name }}&#x3C;/li>\n  &#x3C;/ul>\n&#x3C;/template>\n</code></pre>\n<h2>まとめ</h2>\n<p>Vue Composition API のポイント：</p>\n<ol>\n<li><strong>ref/reactive</strong> - リアクティブデータの作成</li>\n<li><strong>computed</strong> - 算出プロパティ、自動キャッシュ</li>\n<li><strong>watch/watchEffect</strong> - リアクティブ監視</li>\n<li><strong>ライフサイクルフック</strong> - onMounted など</li>\n<li><strong>Composables</strong> - ロジック再利用のベストプラクティス</li>\n</ol>\n"
}