{
  "slug": "hooks",
  "meta": {
    "title": "React Hooks",
    "description": "React Hooks 完全ガイド、カスタム Hooks とベストプラクティス",
    "order": 2,
    "tags": [
      "react",
      "hooks",
      "frontend",
      "state"
    ]
  },
  "content": "<h1>React Hooks</h1>\n<h2>Hooks 概要</h2>\n<p>Hooks は React 16.8 で導入された機能で、関数コンポーネントに状態やライフサイクルなどの機能を提供し、コンポーネント階層を変更せずにロジックを再利用できます。</p>\n<pre><code>よく使う Hooks\n├── useState - 状態管理\n├── useEffect - 副作用処理\n├── useContext - コンテキスト消費\n├── useReducer - 複雑な状態\n├── useRef - 参照と DOM\n├── useMemo - 計算キャッシュ\n├── useCallback - 関数キャッシュ\n└── カスタム Hooks - ロジック再利用\n</code></pre>\n<h2>基本 Hooks</h2>\n<h3>useState</h3>\n<pre><code class=\"language-tsx\">// 基本的な使い方\nconst [count, setCount] = useState(0);\nsetCount(1);\nsetCount(prev => prev + 1);\n\n// オブジェクト状態\nconst [user, setUser] = useState({ name: \"\", age: 0 });\nsetUser(prev => ({ ...prev, name: \"Alice\" }));\n\n// 遅延初期化\nconst [data, setData] = useState(() => {\n  return expensiveComputation();\n});\n\n// 型付き状態\ninterface User {\n  id: string;\n  name: string;\n  email: string;\n}\n\nconst [user, setUser] = useState&#x3C;User | null>(null);\n</code></pre>\n<h3>useEffect</h3>\n<pre><code class=\"language-tsx\">// 基本的な副作用\nuseEffect(() => {\n  document.title = `Count: ${count}`;\n});\n\n// 依存配列\nuseEffect(() => {\n  fetchData(id);\n}, [id]);  // id が変更されたときのみ実行\n\n// クリーンアップ関数\nuseEffect(() => {\n  const subscription = api.subscribe(id);\n  return () => {\n    subscription.unsubscribe();\n  };\n}, [id]);\n\n// マウント時のみ実行\nuseEffect(() => {\n  console.log(\"Component mounted\");\n  return () => console.log(\"Component unmounted\");\n}, []);\n\n// 非同期エフェクト\nuseEffect(() => {\n  const fetchData = async () => {\n    const result = await api.getData();\n    setData(result);\n  };\n  fetchData();\n}, []);\n\n// AbortController でリクエストキャンセル\nuseEffect(() => {\n  const controller = new AbortController();\n\n  fetch(\"/api/data\", { signal: controller.signal })\n    .then(res => res.json())\n    .then(setData)\n    .catch(err => {\n      if (err.name !== \"AbortError\") {\n        setError(err);\n      }\n    });\n\n  return () => controller.abort();\n}, []);\n</code></pre>\n<h3>useContext</h3>\n<pre><code class=\"language-tsx\">// Context 作成\nconst UserContext = createContext&#x3C;User | null>(null);\n\n// Provider\nfunction App() {\n  const [user, setUser] = useState&#x3C;User | null>(null);\n\n  return (\n    &#x3C;UserContext.Provider value={user}>\n      &#x3C;Dashboard />\n    &#x3C;/UserContext.Provider>\n  );\n}\n\n// Context 消費\nfunction Dashboard() {\n  const user = useContext(UserContext);\n\n  if (!user) {\n    return &#x3C;LoginPrompt />;\n  }\n\n  return &#x3C;div>Welcome, {user.name}&#x3C;/div>;\n}\n</code></pre>\n<h3>useReducer</h3>\n<pre><code class=\"language-tsx\">// reducer 定義\ninterface State {\n  count: number;\n  loading: boolean;\n  error: string | null;\n}\n\ntype Action =\n  | { type: \"INCREMENT\" }\n  | { type: \"DECREMENT\" }\n  | { type: \"SET_LOADING\"; payload: boolean }\n  | { type: \"SET_ERROR\"; payload: string };\n\nfunction reducer(state: State, action: Action): State {\n  switch (action.type) {\n    case \"INCREMENT\":\n      return { ...state, count: state.count + 1 };\n    case \"DECREMENT\":\n      return { ...state, count: state.count - 1 };\n    case \"SET_LOADING\":\n      return { ...state, loading: action.payload };\n    case \"SET_ERROR\":\n      return { ...state, error: action.payload };\n    default:\n      return state;\n  }\n}\n\n// reducer 使用\nfunction Counter() {\n  const [state, dispatch] = useReducer(reducer, {\n    count: 0,\n    loading: false,\n    error: null,\n  });\n\n  return (\n    &#x3C;div>\n      &#x3C;span>{state.count}&#x3C;/span>\n      &#x3C;button onClick={() => dispatch({ type: \"INCREMENT\" })}>+&#x3C;/button>\n      &#x3C;button onClick={() => dispatch({ type: \"DECREMENT\" })}>-&#x3C;/button>\n    &#x3C;/div>\n  );\n}\n</code></pre>\n<h3>useRef</h3>\n<pre><code class=\"language-tsx\">// DOM 参照\nfunction TextInput() {\n  const inputRef = useRef&#x3C;HTMLInputElement>(null);\n\n  const focusInput = () => {\n    inputRef.current?.focus();\n  };\n\n  return (\n    &#x3C;>\n      &#x3C;input ref={inputRef} />\n      &#x3C;button onClick={focusInput}>Focus&#x3C;/button>\n    &#x3C;/>\n  );\n}\n\n// ミュータブル値の保存\nfunction Timer() {\n  const intervalRef = useRef&#x3C;number | null>(null);\n  const [count, setCount] = useState(0);\n\n  const start = () => {\n    intervalRef.current = window.setInterval(() => {\n      setCount(c => c + 1);\n    }, 1000);\n  };\n\n  const stop = () => {\n    if (intervalRef.current) {\n      clearInterval(intervalRef.current);\n    }\n  };\n\n  return (\n    &#x3C;div>\n      &#x3C;span>{count}&#x3C;/span>\n      &#x3C;button onClick={start}>Start&#x3C;/button>\n      &#x3C;button onClick={stop}>Stop&#x3C;/button>\n    &#x3C;/div>\n  );\n}\n\n// 前の値を保存\nfunction usePrevious&#x3C;T>(value: T): T | undefined {\n  const ref = useRef&#x3C;T>();\n  useEffect(() => {\n    ref.current = value;\n  });\n  return ref.current;\n}\n</code></pre>\n<h2>パフォーマンス Hooks</h2>\n<h3>useMemo</h3>\n<pre><code class=\"language-tsx\">// 計算結果をキャッシュ\nfunction FilteredList({ items, query }: Props) {\n  const filteredItems = useMemo(() => {\n    return items.filter(item =>\n      item.name.toLowerCase().includes(query.toLowerCase())\n    );\n  }, [items, query]);\n\n  return (\n    &#x3C;ul>\n      {filteredItems.map(item => (\n        &#x3C;li key={item.id}>{item.name}&#x3C;/li>\n      ))}\n    &#x3C;/ul>\n  );\n}\n\n// 複雑なオブジェクトをキャッシュ\nconst chartData = useMemo(() => ({\n  labels: data.map(d => d.date),\n  values: data.map(d => d.value),\n}), [data]);\n</code></pre>\n<h3>useCallback</h3>\n<pre><code class=\"language-tsx\">// コールバック関数をキャッシュ\nfunction Parent() {\n  const [count, setCount] = useState(0);\n\n  const handleClick = useCallback(() => {\n    console.log(\"Clicked\");\n  }, []);\n\n  const handleIncrement = useCallback(() => {\n    setCount(c => c + 1);\n  }, []);\n\n  return (\n    &#x3C;Child onClick={handleClick} onIncrement={handleIncrement} />\n  );\n}\n\n// 外部変数への依存\nconst handleSubmit = useCallback((data: FormData) => {\n  api.submit(userId, data);\n}, [userId]);\n</code></pre>\n<h2>カスタム Hooks</h2>\n<h3>データ取得</h3>\n<pre><code class=\"language-tsx\">interface UseFetchResult&#x3C;T> {\n  data: T | null;\n  loading: boolean;\n  error: Error | null;\n  refetch: () => void;\n}\n\nfunction useFetch&#x3C;T>(url: string): UseFetchResult&#x3C;T> {\n  const [data, setData] = useState&#x3C;T | null>(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState&#x3C;Error | null>(null);\n\n  const fetchData = useCallback(async () => {\n    setLoading(true);\n    setError(null);\n\n    try {\n      const response = await fetch(url);\n      if (!response.ok) throw new Error(\"Fetch failed\");\n      const json = await response.json();\n      setData(json);\n    } catch (err) {\n      setError(err instanceof Error ? err : new Error(\"Unknown error\"));\n    } finally {\n      setLoading(false);\n    }\n  }, [url]);\n\n  useEffect(() => {\n    fetchData();\n  }, [fetchData]);\n\n  return { data, loading, error, refetch: fetchData };\n}\n\n// 使用例\nconst { data, loading, error, refetch } = useFetch&#x3C;User[]>(\"/api/users\");\n</code></pre>\n<h3>ローカルストレージ</h3>\n<pre><code class=\"language-tsx\">function useLocalStorage&#x3C;T>(key: string, initialValue: T) {\n  const [storedValue, setStoredValue] = useState&#x3C;T>(() => {\n    try {\n      const item = window.localStorage.getItem(key);\n      return item ? JSON.parse(item) : initialValue;\n    } catch {\n      return initialValue;\n    }\n  });\n\n  const setValue = useCallback((value: T | ((val: T) => T)) => {\n    try {\n      const valueToStore = value instanceof Function\n        ? value(storedValue)\n        : value;\n      setStoredValue(valueToStore);\n      window.localStorage.setItem(key, JSON.stringify(valueToStore));\n    } catch (error) {\n      console.error(error);\n    }\n  }, [key, storedValue]);\n\n  return [storedValue, setValue] as const;\n}\n\n// 使用例\nconst [theme, setTheme] = useLocalStorage(\"theme\", \"light\");\n</code></pre>\n<h3>デバウンスとスロットル</h3>\n<pre><code class=\"language-tsx\">// デバウンス Hook\nfunction useDebounce&#x3C;T>(value: T, delay: number): T {\n  const [debouncedValue, setDebouncedValue] = useState(value);\n\n  useEffect(() => {\n    const timer = setTimeout(() => {\n      setDebouncedValue(value);\n    }, delay);\n\n    return () => clearTimeout(timer);\n  }, [value, delay]);\n\n  return debouncedValue;\n}\n\n// スロットル Hook\nfunction useThrottle&#x3C;T>(value: T, interval: number): T {\n  const [throttledValue, setThrottledValue] = useState(value);\n  const lastUpdated = useRef(Date.now());\n\n  useEffect(() => {\n    const now = Date.now();\n    if (now >= lastUpdated.current + interval) {\n      lastUpdated.current = now;\n      setThrottledValue(value);\n    } else {\n      const timer = setTimeout(() => {\n        lastUpdated.current = Date.now();\n        setThrottledValue(value);\n      }, interval - (now - lastUpdated.current));\n\n      return () => clearTimeout(timer);\n    }\n  }, [value, interval]);\n\n  return throttledValue;\n}\n\n// 使用例\nconst debouncedSearch = useDebounce(searchTerm, 300);\n</code></pre>\n<h3>ウィンドウサイズ</h3>\n<pre><code class=\"language-tsx\">interface WindowSize {\n  width: number;\n  height: number;\n}\n\nfunction useWindowSize(): WindowSize {\n  const [size, setSize] = useState&#x3C;WindowSize>({\n    width: window.innerWidth,\n    height: window.innerHeight,\n  });\n\n  useEffect(() => {\n    const handleResize = () => {\n      setSize({\n        width: window.innerWidth,\n        height: window.innerHeight,\n      });\n    };\n\n    window.addEventListener(\"resize\", handleResize);\n    return () => window.removeEventListener(\"resize\", handleResize);\n  }, []);\n\n  return size;\n}\n</code></pre>\n<h3>フォーム処理</h3>\n<pre><code class=\"language-tsx\">function useForm&#x3C;T extends Record&#x3C;string, any>>(initialValues: T) {\n  const [values, setValues] = useState(initialValues);\n  const [errors, setErrors] = useState&#x3C;Partial&#x3C;Record&#x3C;keyof T, string>>>({});\n  const [touched, setTouched] = useState&#x3C;Partial&#x3C;Record&#x3C;keyof T, boolean>>>({});\n\n  const handleChange = useCallback((\n    e: React.ChangeEvent&#x3C;HTMLInputElement>\n  ) => {\n    const { name, value } = e.target;\n    setValues(prev => ({ ...prev, [name]: value }));\n  }, []);\n\n  const handleBlur = useCallback((\n    e: React.FocusEvent&#x3C;HTMLInputElement>\n  ) => {\n    const { name } = e.target;\n    setTouched(prev => ({ ...prev, [name]: true }));\n  }, []);\n\n  const reset = useCallback(() => {\n    setValues(initialValues);\n    setErrors({});\n    setTouched({});\n  }, [initialValues]);\n\n  return {\n    values,\n    errors,\n    touched,\n    handleChange,\n    handleBlur,\n    setErrors,\n    reset,\n  };\n}\n</code></pre>\n<h2>React 18+ Hooks</h2>\n<h3>useTransition</h3>\n<pre><code class=\"language-tsx\">function SearchResults() {\n  const [query, setQuery] = useState(\"\");\n  const [isPending, startTransition] = useTransition();\n\n  const handleChange = (e: React.ChangeEvent&#x3C;HTMLInputElement>) => {\n    const value = e.target.value;\n    setQuery(value);  // 緊急更新\n\n    startTransition(() => {\n      setSearchResults(filterResults(value));  // 非緊急更新\n    });\n  };\n\n  return (\n    &#x3C;div>\n      &#x3C;input value={query} onChange={handleChange} />\n      {isPending &#x26;&#x26; &#x3C;Spinner />}\n      &#x3C;ResultList />\n    &#x3C;/div>\n  );\n}\n</code></pre>\n<h3>useDeferredValue</h3>\n<pre><code class=\"language-tsx\">function SearchResults({ query }: { query: string }) {\n  const deferredQuery = useDeferredValue(query);\n  const isStale = query !== deferredQuery;\n\n  return (\n    &#x3C;div style={{ opacity: isStale ? 0.5 : 1 }}>\n      &#x3C;Results query={deferredQuery} />\n    &#x3C;/div>\n  );\n}\n</code></pre>\n<h3>useId</h3>\n<pre><code class=\"language-tsx\">function FormField({ label }: { label: string }) {\n  const id = useId();\n\n  return (\n    &#x3C;div>\n      &#x3C;label htmlFor={id}>{label}&#x3C;/label>\n      &#x3C;input id={id} />\n    &#x3C;/div>\n  );\n}\n</code></pre>\n<h2>まとめ</h2>\n<p>React Hooks のポイント：</p>\n<ol>\n<li><strong>useState</strong> - 基本的な状態管理</li>\n<li><strong>useEffect</strong> - 副作用とライフサイクル</li>\n<li><strong>useContext</strong> - コンポーネント間の状態共有</li>\n<li><strong>useMemo/useCallback</strong> - パフォーマンス最適化</li>\n<li><strong>カスタム Hooks</strong> - ロジックの再利用と抽象化</li>\n</ol>\n"
}