{
  "slug": "ssr",
  "meta": {
    "title": "SSR/SSG レンダリング",
    "description": "Next.js サーバーサイドレンダリング、静的生成と App Router",
    "order": 3,
    "tags": [
      "react",
      "nextjs",
      "ssr",
      "ssg"
    ]
  },
  "content": "<h1>SSR/SSG レンダリング</h1>\n<h2>レンダリングモード概要</h2>\n<p>Next.js は複数のレンダリングモードを提供し、ページの特性に応じて最適な方法を選択できます。</p>\n<pre><code>レンダリングモード\n├── SSR (Server-Side Rendering) - サーバーサイドレンダリング\n├── SSG (Static Site Generation) - 静的生成\n├── ISR (Incremental Static Regeneration) - 増分静的再生成\n├── CSR (Client-Side Rendering) - クライアントサイドレンダリング\n└── Streaming - ストリーミングレンダリング\n</code></pre>\n<h2>App Router (Next.js 13+)</h2>\n<h3>サーバーコンポーネント</h3>\n<pre><code class=\"language-tsx\">// app/page.tsx - デフォルトでサーバーコンポーネント\nasync function HomePage() {\n  // コンポーネント内で直接データ取得\n  const data = await fetch(\"https://api.example.com/data\");\n  const posts = await data.json();\n\n  return (\n    &#x3C;main>\n      &#x3C;h1>Posts&#x3C;/h1>\n      {posts.map((post: Post) => (\n        &#x3C;article key={post.id}>\n          &#x3C;h2>{post.title}&#x3C;/h2>\n          &#x3C;p>{post.excerpt}&#x3C;/p>\n        &#x3C;/article>\n      ))}\n    &#x3C;/main>\n  );\n}\n\nexport default HomePage;\n</code></pre>\n<h3>クライアントコンポーネント</h3>\n<pre><code class=\"language-tsx\">\"use client\";\n\nimport { useState } from \"react\";\n\nexport function Counter() {\n  const [count, setCount] = useState(0);\n\n  return (\n    &#x3C;button onClick={() => setCount(c => c + 1)}>\n      Count: {count}\n    &#x3C;/button>\n  );\n}\n</code></pre>\n<h3>混合使用</h3>\n<pre><code class=\"language-tsx\">// app/dashboard/page.tsx (サーバーコンポーネント)\nimport { Counter } from \"./Counter\";  // クライアントコンポーネント\n\nasync function DashboardPage() {\n  const stats = await getStats();  // サーバーサイドデータ取得\n\n  return (\n    &#x3C;div>\n      &#x3C;h1>Dashboard&#x3C;/h1>\n      &#x3C;Stats data={stats} />\n      &#x3C;Counter />  {/* クライアントインタラクション */}\n    &#x3C;/div>\n  );\n}\n</code></pre>\n<h2>データ取得</h2>\n<h3>サーバーサイドデータ取得</h3>\n<pre><code class=\"language-tsx\">// デフォルトでキャッシュ\nasync function getUser(id: string) {\n  const res = await fetch(`https://api.example.com/users/${id}`);\n  return res.json();\n}\n\n// キャッシュ無効化 (毎回リクエスト)\nasync function getUser(id: string) {\n  const res = await fetch(`https://api.example.com/users/${id}`, {\n    cache: \"no-store\",\n  });\n  return res.json();\n}\n\n// 時間ベース再検証\nasync function getPosts() {\n  const res = await fetch(\"https://api.example.com/posts\", {\n    next: { revalidate: 3600 },  // 1時間ごとに再検証\n  });\n  return res.json();\n}\n\n// タグベース再検証\nasync function getPosts() {\n  const res = await fetch(\"https://api.example.com/posts\", {\n    next: { tags: [\"posts\"] },\n  });\n  return res.json();\n}\n\n// 手動再検証\nimport { revalidateTag, revalidatePath } from \"next/cache\";\n\nasync function createPost(data: PostData) {\n  await db.posts.create(data);\n  revalidateTag(\"posts\");\n  revalidatePath(\"/posts\");\n}\n</code></pre>\n<h3>並列データ取得</h3>\n<pre><code class=\"language-tsx\">async function Dashboard() {\n  // 並列取得 - 推奨\n  const [user, posts, comments] = await Promise.all([\n    getUser(),\n    getPosts(),\n    getComments(),\n  ]);\n\n  return (\n    &#x3C;div>\n      &#x3C;UserProfile user={user} />\n      &#x3C;PostList posts={posts} />\n      &#x3C;CommentList comments={comments} />\n    &#x3C;/div>\n  );\n}\n</code></pre>\n<h3>データプリフェッチ</h3>\n<pre><code class=\"language-tsx\">// データプリフェッチ\nimport { unstable_cache } from \"next/cache\";\n\nconst getCachedUser = unstable_cache(\n  async (id: string) => {\n    return await db.users.findUnique({ where: { id } });\n  },\n  [\"user\"],\n  { revalidate: 3600, tags: [\"user\"] }\n);\n</code></pre>\n<h2>ルーティング</h2>\n<h3>動的ルート</h3>\n<pre><code class=\"language-tsx\">// app/posts/[id]/page.tsx\ninterface Props {\n  params: { id: string };\n}\n\nasync function PostPage({ params }: Props) {\n  const post = await getPost(params.id);\n\n  return (\n    &#x3C;article>\n      &#x3C;h1>{post.title}&#x3C;/h1>\n      &#x3C;div>{post.content}&#x3C;/div>\n    &#x3C;/article>\n  );\n}\n\n// 静的パス生成\nexport async function generateStaticParams() {\n  const posts = await getPosts();\n  return posts.map((post) => ({\n    id: post.id.toString(),\n  }));\n}\n\nexport default PostPage;\n</code></pre>\n<h3>キャッチオールルート</h3>\n<pre><code class=\"language-tsx\">// app/docs/[...slug]/page.tsx\ninterface Props {\n  params: { slug: string[] };\n}\n\nfunction DocsPage({ params }: Props) {\n  // /docs/a/b/c -> slug = ['a', 'b', 'c']\n  return &#x3C;div>Slug: {params.slug.join(\"/\")}&#x3C;/div>;\n}\n</code></pre>\n<h3>ルートグループ</h3>\n<pre><code>app/\n├── (marketing)/\n│   ├── about/page.tsx\n│   └── contact/page.tsx\n├── (shop)/\n│   ├── products/page.tsx\n│   └── cart/page.tsx\n└── layout.tsx\n</code></pre>\n<h2>メタデータ</h2>\n<h3>静的メタデータ</h3>\n<pre><code class=\"language-tsx\">// app/page.tsx\nimport { Metadata } from \"next\";\n\nexport const metadata: Metadata = {\n  title: \"Home Page\",\n  description: \"Welcome to our website\",\n  openGraph: {\n    title: \"Home Page\",\n    description: \"Welcome to our website\",\n    images: [\"/og-image.png\"],\n  },\n};\n</code></pre>\n<h3>動的メタデータ</h3>\n<pre><code class=\"language-tsx\">// app/posts/[id]/page.tsx\nimport { Metadata } from \"next\";\n\ninterface Props {\n  params: { id: string };\n}\n\nexport async function generateMetadata({ params }: Props): Promise&#x3C;Metadata> {\n  const post = await getPost(params.id);\n\n  return {\n    title: post.title,\n    description: post.excerpt,\n    openGraph: {\n      title: post.title,\n      images: [post.image],\n    },\n  };\n}\n</code></pre>\n<h2>ローディングとエラー</h2>\n<h3>ローディング状態</h3>\n<pre><code class=\"language-tsx\">// app/posts/loading.tsx\nexport default function Loading() {\n  return (\n    &#x3C;div className=\"loading\">\n      &#x3C;div className=\"spinner\" />\n      &#x3C;p>Loading...&#x3C;/p>\n    &#x3C;/div>\n  );\n}\n</code></pre>\n<h3>エラーハンドリング</h3>\n<pre><code class=\"language-tsx\">\"use client\";\n\n// app/posts/error.tsx\ninterface Props {\n  error: Error &#x26; { digest?: string };\n  reset: () => void;\n}\n\nexport default function Error({ error, reset }: Props) {\n  return (\n    &#x3C;div className=\"error\">\n      &#x3C;h2>Something went wrong!&#x3C;/h2>\n      &#x3C;p>{error.message}&#x3C;/p>\n      &#x3C;button onClick={reset}>Try again&#x3C;/button>\n    &#x3C;/div>\n  );\n}\n</code></pre>\n<h3>404 ページ</h3>\n<pre><code class=\"language-tsx\">// app/not-found.tsx\nexport default function NotFound() {\n  return (\n    &#x3C;div>\n      &#x3C;h2>Not Found&#x3C;/h2>\n      &#x3C;p>Could not find the requested resource&#x3C;/p>\n    &#x3C;/div>\n  );\n}\n\n// コンポーネント内でトリガー\nimport { notFound } from \"next/navigation\";\n\nasync function PostPage({ params }: Props) {\n  const post = await getPost(params.id);\n\n  if (!post) {\n    notFound();\n  }\n\n  return &#x3C;article>{/* ... */}&#x3C;/article>;\n}\n</code></pre>\n<h2>ストリーミングレンダリング</h2>\n<h3>Suspense</h3>\n<pre><code class=\"language-tsx\">import { Suspense } from \"react\";\n\nasync function Dashboard() {\n  return (\n    &#x3C;div>\n      &#x3C;h1>Dashboard&#x3C;/h1>\n\n      &#x3C;Suspense fallback={&#x3C;LoadingSkeleton />}>\n        &#x3C;SlowComponent />\n      &#x3C;/Suspense>\n\n      &#x3C;Suspense fallback={&#x3C;LoadingSpinner />}>\n        &#x3C;AnotherSlowComponent />\n      &#x3C;/Suspense>\n    &#x3C;/div>\n  );\n}\n</code></pre>\n<h3>ストリーミングデータ</h3>\n<pre><code class=\"language-tsx\">// 長いリストをストリーミング\nasync function PostList() {\n  const posts = await getPosts();\n\n  return (\n    &#x3C;ul>\n      {posts.map((post) => (\n        &#x3C;Suspense key={post.id} fallback={&#x3C;PostSkeleton />}>\n          &#x3C;PostItem id={post.id} />\n        &#x3C;/Suspense>\n      ))}\n    &#x3C;/ul>\n  );\n}\n</code></pre>\n<h2>Server Actions</h2>\n<pre><code class=\"language-tsx\">// app/actions.ts\n\"use server\";\n\nimport { revalidatePath } from \"next/cache\";\n\nexport async function createPost(formData: FormData) {\n  const title = formData.get(\"title\") as string;\n  const content = formData.get(\"content\") as string;\n\n  await db.posts.create({\n    data: { title, content },\n  });\n\n  revalidatePath(\"/posts\");\n}\n\n// app/posts/new/page.tsx\nimport { createPost } from \"../actions\";\n\nexport default function NewPost() {\n  return (\n    &#x3C;form action={createPost}>\n      &#x3C;input name=\"title\" placeholder=\"Title\" />\n      &#x3C;textarea name=\"content\" placeholder=\"Content\" />\n      &#x3C;button type=\"submit\">Create&#x3C;/button>\n    &#x3C;/form>\n  );\n}\n</code></pre>\n<h2>まとめ</h2>\n<p>SSR/SSG レンダリングのポイント：</p>\n<ol>\n<li><strong>サーバーコンポーネント</strong> - デフォルトモード、直接データ取得</li>\n<li><strong>クライアントコンポーネント</strong> - インタラクション、\"use client\" 使用</li>\n<li><strong>データキャッシュ</strong> - fetch キャッシュ、再検証戦略</li>\n<li><strong>ストリーミング</strong> - Suspense で UX 向上</li>\n<li><strong>Server Actions</strong> - サーバーサイドデータ変更</li>\n</ol>\n"
}