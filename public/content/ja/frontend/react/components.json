{
  "slug": "components",
  "meta": {
    "title": "React コンポーネント開発",
    "description": "React コンポーネント設計パターン、コンポーネント間通信とベストプラクティス",
    "order": 1,
    "tags": [
      "react",
      "components",
      "frontend",
      "patterns"
    ]
  },
  "content": "<h1>React コンポーネント開発</h1>\n<h2>コンポーネント基礎</h2>\n<p>React コンポーネントはユーザーインターフェースを構築する基本単位で、関数コンポーネントまたはクラスコンポーネントです。モダン React では Hooks を使用した関数コンポーネントが推奨されます。</p>\n<pre><code>コンポーネントタイプ\n├── 関数コンポーネント - シンプル、Hooks サポート\n├── クラスコンポーネント - 従来の方法、ライフサイクル\n├── 高階コンポーネント - ロジックの再利用\n├── Render Props - 柔軟なレンダリング\n└── 複合コンポーネント - コンポーネント合成パターン\n</code></pre>\n<h2>関数コンポーネント</h2>\n<h3>基本定義</h3>\n<pre><code class=\"language-tsx\">// 基本関数コンポーネント\nfunction Welcome({ name }: { name: string }) {\n  return &#x3C;h1>Hello, {name}&#x3C;/h1>;\n}\n\n// アロー関数コンポーネント\nconst Greeting: React.FC&#x3C;{ name: string }> = ({ name }) => {\n  return &#x3C;h1>Hello, {name}&#x3C;/h1>;\n};\n\n// 子コンポーネント付き\ninterface CardProps {\n  title: string;\n  children: React.ReactNode;\n}\n\nconst Card: React.FC&#x3C;CardProps> = ({ title, children }) => {\n  return (\n    &#x3C;div className=\"card\">\n      &#x3C;h2>{title}&#x3C;/h2>\n      &#x3C;div className=\"card-body\">{children}&#x3C;/div>\n    &#x3C;/div>\n  );\n};\n</code></pre>\n<h3>Props 型</h3>\n<pre><code class=\"language-tsx\">// 完全な Props 型定義\ninterface ButtonProps {\n  // 必須プロパティ\n  label: string;\n  onClick: () => void;\n\n  // オプショナルプロパティ\n  variant?: \"primary\" | \"secondary\" | \"danger\";\n  size?: \"sm\" | \"md\" | \"lg\";\n  disabled?: boolean;\n  icon?: React.ReactNode;\n\n  // スタイルプロパティ\n  className?: string;\n  style?: React.CSSProperties;\n}\n\nconst Button: React.FC&#x3C;ButtonProps> = ({\n  label,\n  onClick,\n  variant = \"primary\",\n  size = \"md\",\n  disabled = false,\n  icon,\n  className,\n  style,\n}) => {\n  return (\n    &#x3C;button\n      className={`btn btn-${variant} btn-${size} ${className ?? \"\"}`}\n      onClick={onClick}\n      disabled={disabled}\n      style={style}\n    >\n      {icon &#x26;&#x26; &#x3C;span className=\"btn-icon\">{icon}&#x3C;/span>}\n      {label}\n    &#x3C;/button>\n  );\n};\n</code></pre>\n<h3>ジェネリックコンポーネント</h3>\n<pre><code class=\"language-tsx\">// ジェネリックリストコンポーネント\ninterface ListProps&#x3C;T> {\n  items: T[];\n  renderItem: (item: T, index: number) => React.ReactNode;\n  keyExtractor: (item: T) => string | number;\n}\n\nfunction List&#x3C;T>({ items, renderItem, keyExtractor }: ListProps&#x3C;T>) {\n  return (\n    &#x3C;ul>\n      {items.map((item, index) => (\n        &#x3C;li key={keyExtractor(item)}>{renderItem(item, index)}&#x3C;/li>\n      ))}\n    &#x3C;/ul>\n  );\n}\n\n// 使用例\n&#x3C;List\n  items={users}\n  keyExtractor={(user) => user.id}\n  renderItem={(user) => &#x3C;span>{user.name}&#x3C;/span>}\n/>\n</code></pre>\n<h2>コンポーネントパターン</h2>\n<h3>複合コンポーネント</h3>\n<pre><code class=\"language-tsx\">// 複合コンポーネントパターン\ninterface TabsContextType {\n  activeTab: string;\n  setActiveTab: (tab: string) => void;\n}\n\nconst TabsContext = React.createContext&#x3C;TabsContextType | null>(null);\n\nfunction Tabs({ children, defaultTab }: { children: React.ReactNode; defaultTab: string }) {\n  const [activeTab, setActiveTab] = useState(defaultTab);\n\n  return (\n    &#x3C;TabsContext.Provider value={{ activeTab, setActiveTab }}>\n      &#x3C;div className=\"tabs\">{children}&#x3C;/div>\n    &#x3C;/TabsContext.Provider>\n  );\n}\n\nfunction TabList({ children }: { children: React.ReactNode }) {\n  return &#x3C;div className=\"tab-list\">{children}&#x3C;/div>;\n}\n\nfunction Tab({ id, children }: { id: string; children: React.ReactNode }) {\n  const context = useContext(TabsContext);\n  if (!context) throw new Error(\"Tab must be used within Tabs\");\n\n  return (\n    &#x3C;button\n      className={context.activeTab === id ? \"active\" : \"\"}\n      onClick={() => context.setActiveTab(id)}\n    >\n      {children}\n    &#x3C;/button>\n  );\n}\n\nfunction TabPanel({ id, children }: { id: string; children: React.ReactNode }) {\n  const context = useContext(TabsContext);\n  if (!context) throw new Error(\"TabPanel must be used within Tabs\");\n\n  return context.activeTab === id ? &#x3C;div>{children}&#x3C;/div> : null;\n}\n\n// 組み合わせエクスポート\nTabs.List = TabList;\nTabs.Tab = Tab;\nTabs.Panel = TabPanel;\n\n// 使用例\n&#x3C;Tabs defaultTab=\"tab1\">\n  &#x3C;Tabs.List>\n    &#x3C;Tabs.Tab id=\"tab1\">Tab 1&#x3C;/Tabs.Tab>\n    &#x3C;Tabs.Tab id=\"tab2\">Tab 2&#x3C;/Tabs.Tab>\n  &#x3C;/Tabs.List>\n  &#x3C;Tabs.Panel id=\"tab1\">Content 1&#x3C;/Tabs.Panel>\n  &#x3C;Tabs.Panel id=\"tab2\">Content 2&#x3C;/Tabs.Panel>\n&#x3C;/Tabs>\n</code></pre>\n<h3>制御・非制御コンポーネント</h3>\n<pre><code class=\"language-tsx\">// 制御コンポーネント\nfunction ControlledInput() {\n  const [value, setValue] = useState(\"\");\n\n  return (\n    &#x3C;input\n      value={value}\n      onChange={(e) => setValue(e.target.value)}\n    />\n  );\n}\n\n// 非制御コンポーネント\nfunction UncontrolledInput() {\n  const inputRef = useRef&#x3C;HTMLInputElement>(null);\n\n  const handleSubmit = () => {\n    console.log(inputRef.current?.value);\n  };\n\n  return &#x3C;input ref={inputRef} defaultValue=\"\" />;\n}\n\n// 制御・非制御両対応\ninterface InputProps {\n  value?: string;\n  defaultValue?: string;\n  onChange?: (value: string) => void;\n}\n\nfunction FlexibleInput({ value, defaultValue, onChange }: InputProps) {\n  const [internalValue, setInternalValue] = useState(defaultValue ?? \"\");\n  const isControlled = value !== undefined;\n  const currentValue = isControlled ? value : internalValue;\n\n  const handleChange = (e: React.ChangeEvent&#x3C;HTMLInputElement>) => {\n    const newValue = e.target.value;\n    if (!isControlled) {\n      setInternalValue(newValue);\n    }\n    onChange?.(newValue);\n  };\n\n  return &#x3C;input value={currentValue} onChange={handleChange} />;\n}\n</code></pre>\n<h3>Render Props</h3>\n<pre><code class=\"language-tsx\">// Render Props パターン\ninterface MouseTrackerProps {\n  render: (position: { x: number; y: number }) => React.ReactNode;\n}\n\nfunction MouseTracker({ render }: MouseTrackerProps) {\n  const [position, setPosition] = useState({ x: 0, y: 0 });\n\n  useEffect(() => {\n    const handleMouseMove = (e: MouseEvent) => {\n      setPosition({ x: e.clientX, y: e.clientY });\n    };\n\n    window.addEventListener(\"mousemove\", handleMouseMove);\n    return () => window.removeEventListener(\"mousemove\", handleMouseMove);\n  }, []);\n\n  return &#x3C;>{render(position)}&#x3C;/>;\n}\n\n// 使用例\n&#x3C;MouseTracker\n  render={({ x, y }) => (\n    &#x3C;div>Mouse position: {x}, {y}&#x3C;/div>\n  )}\n/>\n</code></pre>\n<h2>高階コンポーネント</h2>\n<pre><code class=\"language-tsx\">// 高階コンポーネント (HOC)\nfunction withLoading&#x3C;P extends object>(\n  WrappedComponent: React.ComponentType&#x3C;P>\n) {\n  return function WithLoadingComponent(\n    props: P &#x26; { isLoading: boolean }\n  ) {\n    const { isLoading, ...rest } = props;\n\n    if (isLoading) {\n      return &#x3C;div>Loading...&#x3C;/div>;\n    }\n\n    return &#x3C;WrappedComponent {...(rest as P)} />;\n  };\n}\n\n// 認証付き HOC\nfunction withAuth&#x3C;P extends object>(\n  WrappedComponent: React.ComponentType&#x3C;P>\n) {\n  return function WithAuthComponent(props: P) {\n    const { user, isLoading } = useAuth();\n\n    if (isLoading) return &#x3C;div>Loading...&#x3C;/div>;\n    if (!user) return &#x3C;Navigate to=\"/login\" />;\n\n    return &#x3C;WrappedComponent {...props} />;\n  };\n}\n\n// 使用例\nconst ProtectedDashboard = withAuth(Dashboard);\n</code></pre>\n<h2>コンポーネント間通信</h2>\n<h3>Props 伝達</h3>\n<pre><code class=\"language-tsx\">// 親から子へ\nfunction Parent() {\n  const [count, setCount] = useState(0);\n\n  return (\n    &#x3C;Child\n      count={count}\n      onIncrement={() => setCount(c => c + 1)}\n    />\n  );\n}\n\nfunction Child({ count, onIncrement }: {\n  count: number;\n  onIncrement: () => void;\n}) {\n  return (\n    &#x3C;div>\n      &#x3C;span>{count}&#x3C;/span>\n      &#x3C;button onClick={onIncrement}>+&#x3C;/button>\n    &#x3C;/div>\n  );\n}\n</code></pre>\n<h3>Context 共有</h3>\n<pre><code class=\"language-tsx\">// Context 作成\ninterface ThemeContextType {\n  theme: \"light\" | \"dark\";\n  toggleTheme: () => void;\n}\n\nconst ThemeContext = createContext&#x3C;ThemeContextType | undefined>(undefined);\n\n// Provider\nfunction ThemeProvider({ children }: { children: React.ReactNode }) {\n  const [theme, setTheme] = useState&#x3C;\"light\" | \"dark\">(\"light\");\n\n  const toggleTheme = useCallback(() => {\n    setTheme(t => t === \"light\" ? \"dark\" : \"light\");\n  }, []);\n\n  return (\n    &#x3C;ThemeContext.Provider value={{ theme, toggleTheme }}>\n      {children}\n    &#x3C;/ThemeContext.Provider>\n  );\n}\n\n// カスタム Hook\nfunction useTheme() {\n  const context = useContext(ThemeContext);\n  if (!context) {\n    throw new Error(\"useTheme must be used within ThemeProvider\");\n  }\n  return context;\n}\n\n// 使用例\nfunction ThemedButton() {\n  const { theme, toggleTheme } = useTheme();\n  return (\n    &#x3C;button onClick={toggleTheme}>\n      Current: {theme}\n    &#x3C;/button>\n  );\n}\n</code></pre>\n<h2>パフォーマンス最適化</h2>\n<h3>React.memo</h3>\n<pre><code class=\"language-tsx\">// 不要な再レンダリングを防ぐ\nconst ExpensiveComponent = React.memo(function ExpensiveComponent({\n  data,\n  onUpdate,\n}: {\n  data: Data;\n  onUpdate: () => void;\n}) {\n  // 複雑なレンダリングロジック\n  return &#x3C;div>{/* ... */}&#x3C;/div>;\n});\n\n// カスタム比較関数\nconst OptimizedList = React.memo(\n  function OptimizedList({ items }: { items: Item[] }) {\n    return (\n      &#x3C;ul>\n        {items.map(item => &#x3C;li key={item.id}>{item.name}&#x3C;/li>)}\n      &#x3C;/ul>\n    );\n  },\n  (prevProps, nextProps) => {\n    return prevProps.items.length === nextProps.items.length;\n  }\n);\n</code></pre>\n<h3>useMemo と useCallback</h3>\n<pre><code class=\"language-tsx\">function SearchResults({ query, items }: { query: string; items: Item[] }) {\n  // 計算結果をキャッシュ\n  const filteredItems = useMemo(() => {\n    return items.filter(item =>\n      item.name.toLowerCase().includes(query.toLowerCase())\n    );\n  }, [items, query]);\n\n  // コールバック関数をキャッシュ\n  const handleItemClick = useCallback((id: string) => {\n    console.log(\"Clicked:\", id);\n  }, []);\n\n  return (\n    &#x3C;ul>\n      {filteredItems.map(item => (\n        &#x3C;li key={item.id} onClick={() => handleItemClick(item.id)}>\n          {item.name}\n        &#x3C;/li>\n      ))}\n    &#x3C;/ul>\n  );\n}\n</code></pre>\n<h2>まとめ</h2>\n<p>React コンポーネント開発のポイント：</p>\n<ol>\n<li><strong>関数コンポーネント</strong> - モダン React の推奨方法</li>\n<li><strong>型安全</strong> - TypeScript で保守性向上</li>\n<li><strong>コンポーネントパターン</strong> - 複合、HOC、Render Props</li>\n<li><strong>状態管理</strong> - 制御/非制御、Context</li>\n<li><strong>パフォーマンス最適化</strong> - memo、useMemo、useCallback</li>\n</ol>\n"
}