{
  "slug": "go",
  "meta": {
    "title": "Go 语言基础",
    "description": "Go 语言核心特性、并发编程与云原生开发",
    "order": 1,
    "tags": [
      "go",
      "golang",
      "compiled",
      "concurrency"
    ]
  },
  "content": "<h1>Go 语言基础</h1>\n<h2>Go 语言概述</h2>\n<p>Go (Golang) 是 Google 开发的静态类型、编译型语言，以简洁、高效和强大的并发支持著称，是云原生开发的首选语言。</p>\n<pre><code>Go 特点\n├── 编译型 - 直接编译为机器码\n├── 静态类型 - 编译时类型检查\n├── 垃圾回收 - 自动内存管理\n├── 并发原生 - goroutine + channel\n└── 交叉编译 - 轻松跨平台\n</code></pre>\n<h2>基础语法</h2>\n<h3>变量与类型</h3>\n<pre><code class=\"language-go\">package main\n\nimport \"fmt\"\n\nfunc main() {\n    // 变量声明\n    var name string = \"Go\"\n    var age int = 15\n    var isCompiled bool = true\n\n    // 短变量声明 (类型推断)\n    version := \"1.21\"\n    count := 100\n\n    // 多变量声明\n    var x, y, z int = 1, 2, 3\n    a, b := \"hello\", \"world\"\n\n    // 常量\n    const Pi = 3.14159\n    const (\n        StatusOK = 200\n        StatusNotFound = 404\n    )\n\n    // 基本类型\n    var (\n        i8  int8    = 127\n        i16 int16   = 32767\n        i32 int32   = 2147483647\n        i64 int64   = 9223372036854775807\n\n        u8  uint8   = 255\n        u32 uint32  = 4294967295\n\n        f32 float32 = 3.14\n        f64 float64 = 3.141592653589793\n\n        c64  complex64  = 1 + 2i\n        c128 complex128 = 1 + 2i\n\n        b   byte = 'A'  // uint8 别名\n        r   rune = '中' // int32 别名，表示 Unicode\n    )\n\n    fmt.Println(name, version)\n}\n</code></pre>\n<h3>复合类型</h3>\n<pre><code class=\"language-go\">// 数组 - 固定长度\nvar arr [5]int = [5]int{1, 2, 3, 4, 5}\narr2 := [...]int{1, 2, 3}  // 自动推断长度\n\n// 切片 - 动态数组\nslice := []int{1, 2, 3}\nslice = append(slice, 4, 5)\n\n// 从数组创建切片\ns := arr[1:4]  // [2, 3, 4]\n\n// make 创建切片\ns2 := make([]int, 5)      // len=5, cap=5\ns3 := make([]int, 5, 10)  // len=5, cap=10\n\n// Map\nm := map[string]int{\n    \"apple\":  1,\n    \"banana\": 2,\n}\nm[\"cherry\"] = 3\n\nvalue, exists := m[\"apple\"]\nif exists {\n    fmt.Println(value)\n}\n\ndelete(m, \"apple\")\n\n// 结构体\ntype Person struct {\n    Name string\n    Age  int\n    City string `json:\"city\"`  // 标签\n}\n\np := Person{Name: \"Alice\", Age: 30}\np2 := Person{\"Bob\", 25, \"Tokyo\"}\n\n// 指针\nptr := &#x26;p\nfmt.Println(ptr.Name)  // 自动解引用\n</code></pre>\n<h3>控制流</h3>\n<pre><code class=\"language-go\">// if-else\nif x > 0 {\n    fmt.Println(\"positive\")\n} else if x &#x3C; 0 {\n    fmt.Println(\"negative\")\n} else {\n    fmt.Println(\"zero\")\n}\n\n// if 带初始化\nif err := doSomething(); err != nil {\n    fmt.Println(err)\n}\n\n// switch\nswitch day {\ncase \"Monday\", \"Tuesday\":\n    fmt.Println(\"weekday\")\ncase \"Saturday\", \"Sunday\":\n    fmt.Println(\"weekend\")\ndefault:\n    fmt.Println(\"unknown\")\n}\n\n// switch 无表达式\nswitch {\ncase score >= 90:\n    grade = \"A\"\ncase score >= 80:\n    grade = \"B\"\ndefault:\n    grade = \"C\"\n}\n\n// for 循环 (Go 只有 for)\nfor i := 0; i &#x3C; 10; i++ {\n    fmt.Println(i)\n}\n\n// while 风格\nfor count > 0 {\n    count--\n}\n\n// 无限循环\nfor {\n    // break 退出\n}\n\n// range 遍历\nfor i, v := range slice {\n    fmt.Printf(\"index: %d, value: %d\\n\", i, v)\n}\n\nfor key, value := range m {\n    fmt.Printf(\"%s: %d\\n\", key, value)\n}\n</code></pre>\n<h3>函数</h3>\n<pre><code class=\"language-go\">// 基本函数\nfunc add(a, b int) int {\n    return a + b\n}\n\n// 多返回值\nfunc divide(a, b float64) (float64, error) {\n    if b == 0 {\n        return 0, errors.New(\"division by zero\")\n    }\n    return a / b, nil\n}\n\n// 命名返回值\nfunc split(sum int) (x, y int) {\n    x = sum * 4 / 9\n    y = sum - x\n    return  // 裸返回\n}\n\n// 可变参数\nfunc sum(nums ...int) int {\n    total := 0\n    for _, n := range nums {\n        total += n\n    }\n    return total\n}\n\n// 函数作为值\nfn := func(x int) int { return x * x }\nresult := fn(5)\n\n// 闭包\nfunc counter() func() int {\n    count := 0\n    return func() int {\n        count++\n        return count\n    }\n}\n\n// defer - 延迟执行\nfunc readFile(path string) error {\n    f, err := os.Open(path)\n    if err != nil {\n        return err\n    }\n    defer f.Close()  // 函数返回前执行\n\n    // 处理文件...\n    return nil\n}\n</code></pre>\n<h3>方法与接口</h3>\n<pre><code class=\"language-go\">// 方法\ntype Rectangle struct {\n    Width, Height float64\n}\n\nfunc (r Rectangle) Area() float64 {\n    return r.Width * r.Height\n}\n\nfunc (r *Rectangle) Scale(factor float64) {\n    r.Width *= factor\n    r.Height *= factor\n}\n\n// 接口\ntype Shape interface {\n    Area() float64\n    Perimeter() float64\n}\n\ntype Circle struct {\n    Radius float64\n}\n\nfunc (c Circle) Area() float64 {\n    return math.Pi * c.Radius * c.Radius\n}\n\nfunc (c Circle) Perimeter() float64 {\n    return 2 * math.Pi * c.Radius\n}\n\n// Circle 自动实现了 Shape 接口\n\n// 空接口\nfunc printAny(v interface{}) {\n    fmt.Println(v)\n}\n\n// 类型断言\nfunc process(v interface{}) {\n    if s, ok := v.(string); ok {\n        fmt.Println(\"string:\", s)\n    }\n\n    // type switch\n    switch val := v.(type) {\n    case int:\n        fmt.Println(\"int:\", val)\n    case string:\n        fmt.Println(\"string:\", val)\n    default:\n        fmt.Println(\"unknown type\")\n    }\n}\n</code></pre>\n<h2>并发编程</h2>\n<h3>Goroutine</h3>\n<pre><code class=\"language-go\">// 启动 goroutine\ngo func() {\n    fmt.Println(\"Hello from goroutine\")\n}()\n\n// 带参数\ngo func(msg string) {\n    fmt.Println(msg)\n}(\"Hello\")\n\n// 等待完成\nvar wg sync.WaitGroup\n\nfor i := 0; i &#x3C; 5; i++ {\n    wg.Add(1)\n    go func(n int) {\n        defer wg.Done()\n        fmt.Println(n)\n    }(i)\n}\n\nwg.Wait()\n</code></pre>\n<h3>Channel</h3>\n<pre><code class=\"language-go\">// 创建 channel\nch := make(chan int)        // 无缓冲\nch := make(chan int, 10)    // 有缓冲\n\n// 发送和接收\nch &#x3C;- 42        // 发送\nvalue := &#x3C;-ch   // 接收\n\n// 关闭 channel\nclose(ch)\n\n// 遍历 channel\nfor v := range ch {\n    fmt.Println(v)\n}\n\n// select 多路复用\nselect {\ncase msg := &#x3C;-ch1:\n    fmt.Println(\"from ch1:\", msg)\ncase msg := &#x3C;-ch2:\n    fmt.Println(\"from ch2:\", msg)\ncase &#x3C;-time.After(time.Second):\n    fmt.Println(\"timeout\")\ndefault:\n    fmt.Println(\"no message\")\n}\n</code></pre>\n<h3>并发模式</h3>\n<pre><code class=\"language-go\">// Worker Pool\nfunc worker(id int, jobs &#x3C;-chan int, results chan&#x3C;- int) {\n    for j := range jobs {\n        results &#x3C;- j * 2\n    }\n}\n\nfunc main() {\n    jobs := make(chan int, 100)\n    results := make(chan int, 100)\n\n    // 启动 3 个 worker\n    for w := 1; w &#x3C;= 3; w++ {\n        go worker(w, jobs, results)\n    }\n\n    // 发送任务\n    for j := 1; j &#x3C;= 9; j++ {\n        jobs &#x3C;- j\n    }\n    close(jobs)\n\n    // 收集结果\n    for a := 1; a &#x3C;= 9; a++ {\n        &#x3C;-results\n    }\n}\n\n// Context 控制\nfunc longRunningTask(ctx context.Context) error {\n    for {\n        select {\n        case &#x3C;-ctx.Done():\n            return ctx.Err()\n        default:\n            // 执行任务\n        }\n    }\n}\n\nctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\ndefer cancel()\n\ngo longRunningTask(ctx)\n</code></pre>\n<h2>错误处理</h2>\n<pre><code class=\"language-go\">// 返回错误\nfunc readConfig(path string) (*Config, error) {\n    data, err := os.ReadFile(path)\n    if err != nil {\n        return nil, fmt.Errorf(\"failed to read config: %w\", err)\n    }\n\n    var cfg Config\n    if err := json.Unmarshal(data, &#x26;cfg); err != nil {\n        return nil, fmt.Errorf(\"failed to parse config: %w\", err)\n    }\n\n    return &#x26;cfg, nil\n}\n\n// 自定义错误\ntype ValidationError struct {\n    Field   string\n    Message string\n}\n\nfunc (e *ValidationError) Error() string {\n    return fmt.Sprintf(\"%s: %s\", e.Field, e.Message)\n}\n\n// 错误检查\nif errors.Is(err, os.ErrNotExist) {\n    // 文件不存在\n}\n\nvar validErr *ValidationError\nif errors.As(err, &#x26;validErr) {\n    fmt.Println(validErr.Field)\n}\n\n// panic 和 recover\nfunc safeDivide(a, b int) (result int, err error) {\n    defer func() {\n        if r := recover(); r != nil {\n            err = fmt.Errorf(\"panic: %v\", r)\n        }\n    }()\n\n    return a / b, nil\n}\n</code></pre>\n<h2>泛型 (Go 1.18+)</h2>\n<pre><code class=\"language-go\">// 泛型函数\nfunc Min[T constraints.Ordered](a, b T) T {\n    if a &#x3C; b {\n        return a\n    }\n    return b\n}\n\n// 泛型类型\ntype Stack[T any] struct {\n    items []T\n}\n\nfunc (s *Stack[T]) Push(item T) {\n    s.items = append(s.items, item)\n}\n\nfunc (s *Stack[T]) Pop() (T, bool) {\n    if len(s.items) == 0 {\n        var zero T\n        return zero, false\n    }\n    item := s.items[len(s.items)-1]\n    s.items = s.items[:len(s.items)-1]\n    return item, true\n}\n\n// 类型约束\ntype Number interface {\n    int | int32 | int64 | float32 | float64\n}\n\nfunc Sum[T Number](nums []T) T {\n    var total T\n    for _, n := range nums {\n        total += n\n    }\n    return total\n}\n</code></pre>\n<h2>常用标准库</h2>\n<pre><code class=\"language-go\">// fmt - 格式化 I/O\nfmt.Printf(\"Name: %s, Age: %d\\n\", name, age)\nfmt.Sprintf(\"Hello, %s\", name)\n\n// strings\nstrings.Contains(\"hello\", \"ell\")\nstrings.Split(\"a,b,c\", \",\")\nstrings.Join([]string{\"a\", \"b\"}, \"-\")\n\n// strconv\ni, _ := strconv.Atoi(\"42\")\ns := strconv.Itoa(42)\n\n// time\nnow := time.Now()\ntime.Sleep(time.Second)\nt := time.Date(2024, 1, 1, 0, 0, 0, 0, time.UTC)\nt.Format(\"2006-01-02 15:04:05\")  // Go 特有格式\n\n// encoding/json\ndata, _ := json.Marshal(obj)\njson.Unmarshal(data, &#x26;obj)\n\n// net/http\nhttp.HandleFunc(\"/\", handler)\nhttp.ListenAndServe(\":8080\", nil)\n\n// os\nos.Getenv(\"HOME\")\nos.ReadFile(\"file.txt\")\nos.WriteFile(\"file.txt\", data, 0644)\n\n// path/filepath\nfilepath.Join(\"dir\", \"file.txt\")\nfilepath.Glob(\"*.go\")\n\n// sync\nvar mu sync.Mutex\nvar once sync.Once\nvar pool sync.Pool\n</code></pre>\n<h2>项目结构</h2>\n<pre><code>myproject/\n├── cmd/\n│   └── myapp/\n│       └── main.go\n├── internal/\n│   ├── handler/\n│   ├── service/\n│   └── repository/\n├── pkg/\n│   └── utils/\n├── api/\n│   └── openapi.yaml\n├── configs/\n├── go.mod\n├── go.sum\n└── Makefile\n</code></pre>\n<h2>总结</h2>\n<p>Go 语言核心要点：</p>\n<ol>\n<li><strong>简洁设计</strong> - 语法简单，学习曲线平缓</li>\n<li><strong>并发原生</strong> - goroutine 轻量级协程</li>\n<li><strong>快速编译</strong> - 编译速度极快</li>\n<li><strong>静态链接</strong> - 单二进制文件部署</li>\n<li><strong>云原生首选</strong> - Docker, K8s 都用 Go 编写</li>\n</ol>\n"
}