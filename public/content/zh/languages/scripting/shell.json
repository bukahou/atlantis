{
  "slug": "shell",
  "meta": {
    "title": "Shell 脚本基础",
    "description": "Bash/Shell 脚本编程、常用命令与自动化运维",
    "order": 2,
    "tags": [
      "shell",
      "bash",
      "scripting",
      "automation"
    ]
  },
  "content": "<h1>Shell 脚本基础</h1>\n<h2>Shell 概述</h2>\n<p>Shell 是操作系统的命令行解释器，Bash (Bourne Again Shell) 是最常用的 Shell，广泛用于系统管理、自动化运维和 DevOps 流程。</p>\n<pre><code>Shell 特点\n├── 系统交互 - 直接与操作系统交互\n├── 脚本自动化 - 批量执行任务\n├── 管道机制 - 命令组合处理\n├── 文本处理 - 强大的文本操作能力\n└── 跨平台 - Linux/macOS/WSL\n</code></pre>\n<h2>基础语法</h2>\n<h3>脚本结构</h3>\n<pre><code class=\"language-bash\">#!/bin/bash\n# Shebang 指定解释器\n\n# 这是注释\n\n# 变量\nNAME=\"Shell\"\nVERSION=5\n\n# 使用变量\necho \"Welcome to $NAME\"\necho \"Version: ${VERSION}\"\n\n# 命令执行\ncurrent_date=$(date +%Y-%m-%d)\nfile_count=`ls | wc -l`\n\n# 退出状态\nexit 0\n</code></pre>\n<h3>变量</h3>\n<pre><code class=\"language-bash\"># 变量赋值 (等号两边不能有空格)\nname=\"Alice\"\nage=30\nreadonly PI=3.14159\n\n# 字符串\nstr1=\"Hello\"\nstr2='World'\ncombined=\"$str1 $str2\"\nlength=${#str1}  # 字符串长度\n\n# 字符串操作\n${str:0:5}       # 子串 (从0开始取5个)\n${str#*/}        # 删除最短前缀\n${str##*/}       # 删除最长前缀\n${str%/*}        # 删除最短后缀\n${str%%/*}       # 删除最长后缀\n${str/old/new}   # 替换第一个\n${str//old/new}  # 替换所有\n\n# 默认值\n${var:-default}  # var 未设置则用 default\n${var:=default}  # var 未设置则赋值 default\n${var:+value}    # var 已设置则用 value\n${var:?error}    # var 未设置则报错\n\n# 数组\narr=(a b c d e)\necho ${arr[0]}       # 第一个元素\necho ${arr[@]}       # 所有元素\necho ${#arr[@]}      # 数组长度\narr+=(f g)           # 追加元素\n\n# 关联数组 (Bash 4+)\ndeclare -A map\nmap[name]=\"Alice\"\nmap[age]=30\necho ${map[name]}\necho ${!map[@]}      # 所有键\n</code></pre>\n<h3>特殊变量</h3>\n<pre><code class=\"language-bash\">$0          # 脚本名\n$1 $2 ...   # 位置参数\n$#          # 参数个数\n$@          # 所有参数 (独立字符串)\n$*          # 所有参数 (单个字符串)\n$?          # 上个命令退出状态\n$$          # 当前脚本 PID\n$!          # 后台进程 PID\n$_          # 上个命令最后一个参数\n</code></pre>\n<h2>控制流</h2>\n<h3>条件判断</h3>\n<pre><code class=\"language-bash\"># if-elif-else\nif [ \"$age\" -ge 18 ]; then\n    echo \"Adult\"\nelif [ \"$age\" -ge 13 ]; then\n    echo \"Teen\"\nelse\n    echo \"Child\"\nfi\n\n# [[ ]] 扩展测试 (推荐)\nif [[ \"$name\" == \"Alice\" &#x26;&#x26; \"$age\" -gt 20 ]]; then\n    echo \"Match\"\nfi\n\n# 正则匹配\nif [[ \"$email\" =~ ^[a-zA-Z0-9]+@[a-zA-Z0-9]+\\.[a-zA-Z]+$ ]]; then\n    echo \"Valid email\"\nfi\n\n# 文件测试\nif [[ -f \"$file\" ]]; then echo \"是文件\"; fi\nif [[ -d \"$dir\" ]]; then echo \"是目录\"; fi\nif [[ -e \"$path\" ]]; then echo \"存在\"; fi\nif [[ -r \"$file\" ]]; then echo \"可读\"; fi\nif [[ -w \"$file\" ]]; then echo \"可写\"; fi\nif [[ -x \"$file\" ]]; then echo \"可执行\"; fi\nif [[ -s \"$file\" ]]; then echo \"非空\"; fi\n\n# 字符串测试\nif [[ -z \"$str\" ]]; then echo \"空字符串\"; fi\nif [[ -n \"$str\" ]]; then echo \"非空字符串\"; fi\n\n# 数值比较\n# -eq (等于) -ne (不等于) -lt (小于)\n# -le (小于等于) -gt (大于) -ge (大于等于)\n</code></pre>\n<h3>case 语句</h3>\n<pre><code class=\"language-bash\">case \"$option\" in\n    start)\n        echo \"Starting...\"\n        ;;\n    stop)\n        echo \"Stopping...\"\n        ;;\n    restart|reload)\n        echo \"Restarting...\"\n        ;;\n    *)\n        echo \"Unknown option\"\n        exit 1\n        ;;\nesac\n</code></pre>\n<h3>循环</h3>\n<pre><code class=\"language-bash\"># for 循环\nfor i in 1 2 3 4 5; do\n    echo $i\ndone\n\nfor i in {1..10}; do\n    echo $i\ndone\n\nfor i in {0..100..10}; do  # 步长 10\n    echo $i\ndone\n\nfor file in *.txt; do\n    echo \"Processing $file\"\ndone\n\n# C 风格 for\nfor ((i=0; i&#x3C;10; i++)); do\n    echo $i\ndone\n\n# while 循环\ncount=0\nwhile [ $count -lt 5 ]; do\n    echo $count\n    ((count++))\ndone\n\n# 读取文件\nwhile IFS= read -r line; do\n    echo \"$line\"\ndone &#x3C; file.txt\n\n# until 循环\nuntil [ $count -eq 0 ]; do\n    ((count--))\ndone\n\n# 循环控制\nbreak       # 退出循环\ncontinue    # 跳过本次\n</code></pre>\n<h2>函数</h2>\n<pre><code class=\"language-bash\"># 函数定义\nfunction greet() {\n    echo \"Hello, $1!\"\n}\n\n# 简写形式\nsay_bye() {\n    echo \"Goodbye, $1!\"\n    return 0\n}\n\n# 调用\ngreet \"Alice\"\nsay_bye \"Bob\"\n\n# 获取返回值\nresult=$(greet \"World\")\nstatus=$?\n\n# 局部变量\ncalculate() {\n    local result=$(( $1 + $2 ))\n    echo $result\n}\n\nsum=$(calculate 10 20)\n\n# 参数处理\nprocess_args() {\n    while [[ $# -gt 0 ]]; do\n        case \"$1\" in\n            -n|--name)\n                name=\"$2\"\n                shift 2\n                ;;\n            -v|--verbose)\n                verbose=1\n                shift\n                ;;\n            *)\n                echo \"Unknown: $1\"\n                shift\n                ;;\n        esac\n    done\n}\n</code></pre>\n<h2>输入输出</h2>\n<h3>重定向</h3>\n<pre><code class=\"language-bash\"># 输出重定向\ncommand > file      # 覆盖\ncommand >> file     # 追加\ncommand 2> file     # 错误输出\ncommand &#x26;> file     # 所有输出\ncommand 2>&#x26;1        # 错误重定向到标准输出\n\n# 输入重定向\ncommand &#x3C; file\ncommand &#x3C;&#x3C; EOF\n多行输入\nEOF\n\n# Here String\ncommand &#x3C;&#x3C;&#x3C; \"string\"\n\n# 丢弃输出\ncommand > /dev/null 2>&#x26;1\ncommand &#x26;> /dev/null\n</code></pre>\n<h3>管道</h3>\n<pre><code class=\"language-bash\"># 基本管道\ncat file | grep \"pattern\" | sort | uniq\n\n# 常用组合\nps aux | grep nginx\nls -la | head -10\ncat log.txt | tail -100 | grep ERROR\n\n# tee 同时输出到文件和屏幕\ncommand | tee output.txt\ncommand | tee -a output.txt  # 追加\n\n# xargs 参数传递\nfind . -name \"*.log\" | xargs rm\nfind . -name \"*.txt\" | xargs -I {} cp {} backup/\n</code></pre>\n<h3>用户交互</h3>\n<pre><code class=\"language-bash\"># 读取输入\nread -p \"Enter name: \" name\nread -s -p \"Enter password: \" password  # 不回显\nread -t 5 -p \"Quick! \" answer  # 超时\n\n# 选择菜单\nselect opt in \"Option1\" \"Option2\" \"Quit\"; do\n    case $opt in\n        \"Option1\") echo \"Selected 1\" ;;\n        \"Option2\") echo \"Selected 2\" ;;\n        \"Quit\") break ;;\n    esac\ndone\n</code></pre>\n<h2>文本处理</h2>\n<h3>grep</h3>\n<pre><code class=\"language-bash\">grep \"pattern\" file\ngrep -i \"pattern\" file      # 忽略大小写\ngrep -r \"pattern\" dir/      # 递归搜索\ngrep -n \"pattern\" file      # 显示行号\ngrep -v \"pattern\" file      # 反向匹配\ngrep -E \"regex\" file        # 扩展正则\ngrep -c \"pattern\" file      # 计数\ngrep -l \"pattern\" *.txt     # 只显示文件名\ngrep -A 3 \"pattern\" file    # 后3行\ngrep -B 3 \"pattern\" file    # 前3行\n</code></pre>\n<h3>sed</h3>\n<pre><code class=\"language-bash\"># 替换\nsed 's/old/new/' file       # 替换第一个\nsed 's/old/new/g' file      # 替换所有\nsed -i 's/old/new/g' file   # 原地修改\n\n# 删除\nsed '/pattern/d' file       # 删除匹配行\nsed '1d' file               # 删除第一行\nsed '1,5d' file             # 删除1-5行\n\n# 打印\nsed -n '5p' file            # 打印第5行\nsed -n '1,10p' file         # 打印1-10行\nsed -n '/pattern/p' file    # 打印匹配行\n\n# 插入\nsed '3i\\new line' file      # 第3行前插入\nsed '3a\\new line' file      # 第3行后插入\n</code></pre>\n<h3>awk</h3>\n<pre><code class=\"language-bash\"># 基本用法\nawk '{print $1}' file           # 打印第一列\nawk '{print $1, $3}' file       # 打印第1和第3列\nawk -F: '{print $1}' /etc/passwd  # 指定分隔符\n\n# 条件过滤\nawk '$3 > 100 {print $1}' file\nawk '/pattern/ {print}' file\n\n# 内置变量\nawk '{print NR, $0}' file   # NR 行号\nawk '{print NF}' file       # NF 字段数\nawk 'END {print NR}' file   # 总行数\n\n# 计算\nawk '{sum += $1} END {print sum}' file\nawk '{sum += $1; count++} END {print sum/count}' file\n\n# BEGIN/END\nawk 'BEGIN {print \"Start\"} {print} END {print \"End\"}' file\n</code></pre>\n<h2>常用命令</h2>\n<h3>文件操作</h3>\n<pre><code class=\"language-bash\"># 查找\nfind . -name \"*.txt\"\nfind . -type f -mtime -7     # 7天内修改\nfind . -size +100M           # 大于100M\nfind . -name \"*.log\" -exec rm {} \\;\n\n# 压缩解压\ntar -czvf archive.tar.gz dir/\ntar -xzvf archive.tar.gz\nzip -r archive.zip dir/\nunzip archive.zip\n\n# 权限\nchmod 755 file\nchmod +x script.sh\nchown user:group file\n</code></pre>\n<h3>进程管理</h3>\n<pre><code class=\"language-bash\"># 查看进程\nps aux\nps aux | grep nginx\npgrep -f \"pattern\"\ntop\nhtop\n\n# 进程控制\nkill PID\nkill -9 PID          # 强制终止\nkillall process_name\npkill -f \"pattern\"\n\n# 后台运行\ncommand &#x26;\nnohup command &#x26;\nnohup command > output.log 2>&#x26;1 &#x26;\n</code></pre>\n<h3>网络</h3>\n<pre><code class=\"language-bash\"># 网络诊断\nping host\ncurl -I http://example.com\nwget http://example.com/file\nnc -zv host port\n\n# 端口查看\nnetstat -tlnp\nss -tlnp\nlsof -i :8080\n</code></pre>\n<h2>实用脚本模式</h2>\n<h3>错误处理</h3>\n<pre><code class=\"language-bash\">#!/bin/bash\nset -e          # 遇错退出\nset -u          # 未定义变量报错\nset -o pipefail # 管道错误检测\nset -x          # 调试模式\n\n# 清理函数\ncleanup() {\n    rm -f \"$temp_file\"\n}\ntrap cleanup EXIT\n\n# 错误处理\nerror_exit() {\n    echo \"Error: $1\" >&#x26;2\n    exit 1\n}\n\n# 使用\ncommand || error_exit \"Command failed\"\n</code></pre>\n<h3>日志记录</h3>\n<pre><code class=\"language-bash\">#!/bin/bash\nLOG_FILE=\"/var/log/myscript.log\"\n\nlog() {\n    local level=$1\n    shift\n    echo \"[$(date '+%Y-%m-%d %H:%M:%S')] [$level] $*\" | tee -a \"$LOG_FILE\"\n}\n\nlog INFO \"Script started\"\nlog ERROR \"Something went wrong\"\nlog INFO \"Script finished\"\n</code></pre>\n<h3>配置文件解析</h3>\n<pre><code class=\"language-bash\">#!/bin/bash\n# config.conf: KEY=VALUE 格式\n\nif [[ -f config.conf ]]; then\n    source config.conf\nfi\n\n# 或逐行解析\nwhile IFS='=' read -r key value; do\n    [[ \"$key\" =~ ^#.*$ ]] &#x26;&#x26; continue\n    [[ -z \"$key\" ]] &#x26;&#x26; continue\n    declare \"$key=$value\"\ndone &#x3C; config.conf\n</code></pre>\n<h2>总结</h2>\n<p>Shell 脚本核心要点：</p>\n<ol>\n<li><strong>系统交互</strong> - 直接操作文件、进程、网络</li>\n<li><strong>文本处理</strong> - grep/sed/awk 三剑客</li>\n<li><strong>管道机制</strong> - 命令组合的强大能力</li>\n<li><strong>自动化</strong> - 批量任务、定时任务</li>\n<li><strong>运维必备</strong> - 系统管理、部署脚本</li>\n</ol>\n"
}