{
  "slug": "composition",
  "meta": {
    "title": "Vue 组合式 API",
    "description": "Vue 3 Composition API 核心概念与响应式系统",
    "order": 1,
    "tags": [
      "vue",
      "composition",
      "frontend",
      "reactive"
    ]
  },
  "content": "<h1>Vue 组合式 API</h1>\n<h2>组合式 API 概述</h2>\n<p>Vue 3 的组合式 API 提供了一种更灵活的方式来组织组件逻辑，便于逻辑复用和代码组织。</p>\n<pre><code>组合式 API 核心\n├── ref / reactive - 响应式数据\n├── computed - 计算属性\n├── watch / watchEffect - 侦听器\n├── 生命周期钩子 - onMounted 等\n└── 依赖注入 - provide / inject\n</code></pre>\n<h2>响应式基础</h2>\n<h3>ref</h3>\n<pre><code class=\"language-vue\">&#x3C;script setup lang=\"ts\">\nimport { ref } from \"vue\";\n\n// 基本类型\nconst count = ref(0);\nconst name = ref(\"Vue\");\n\n// 访问和修改\nconsole.log(count.value);\ncount.value++;\n\n// 类型推断\nconst message = ref(\"Hello\");  // Ref&#x3C;string>\n\n// 显式类型\nconst user = ref&#x3C;User | null>(null);\n&#x3C;/script>\n\n&#x3C;template>\n  &#x3C;!-- 模板中自动解包 -->\n  &#x3C;div>{{ count }}&#x3C;/div>\n  &#x3C;button @click=\"count++\">+1&#x3C;/button>\n&#x3C;/template>\n</code></pre>\n<h3>reactive</h3>\n<pre><code class=\"language-vue\">&#x3C;script setup lang=\"ts\">\nimport { reactive } from \"vue\";\n\n// 对象响应式\nconst state = reactive({\n  count: 0,\n  user: {\n    name: \"Alice\",\n    age: 30,\n  },\n  items: [] as string[],\n});\n\n// 直接修改\nstate.count++;\nstate.user.name = \"Bob\";\nstate.items.push(\"item\");\n\n// 类型定义\ninterface State {\n  count: number;\n  user: User;\n  items: string[];\n}\n\nconst typedState = reactive&#x3C;State>({\n  count: 0,\n  user: { name: \"\", age: 0 },\n  items: [],\n});\n&#x3C;/script>\n</code></pre>\n<h3>ref vs reactive</h3>\n<pre><code class=\"language-vue\">&#x3C;script setup lang=\"ts\">\nimport { ref, reactive, toRefs } from \"vue\";\n\n// ref - 适用于基本类型，需要 .value\nconst count = ref(0);\ncount.value++;\n\n// reactive - 适用于对象，不需要 .value\nconst state = reactive({ count: 0 });\nstate.count++;\n\n// toRefs - 解构响应式对象\nconst { count: countRef } = toRefs(state);\n\n// shallowRef - 浅层响应\nconst shallowState = shallowRef({ nested: { value: 1 } });\n// 只有 shallowState.value 的替换才会触发更新\n&#x3C;/script>\n</code></pre>\n<h2>计算属性</h2>\n<pre><code class=\"language-vue\">&#x3C;script setup lang=\"ts\">\nimport { ref, computed } from \"vue\";\n\nconst firstName = ref(\"John\");\nconst lastName = ref(\"Doe\");\n\n// 只读计算属性\nconst fullName = computed(() => {\n  return `${firstName.value} ${lastName.value}`;\n});\n\n// 可写计算属性\nconst fullNameWritable = computed({\n  get() {\n    return `${firstName.value} ${lastName.value}`;\n  },\n  set(newValue: string) {\n    const parts = newValue.split(\" \");\n    firstName.value = parts[0];\n    lastName.value = parts[1] || \"\";\n  },\n});\n\nfullNameWritable.value = \"Jane Smith\";\n&#x3C;/script>\n</code></pre>\n<h2>侦听器</h2>\n<h3>watch</h3>\n<pre><code class=\"language-vue\">&#x3C;script setup lang=\"ts\">\nimport { ref, watch } from \"vue\";\n\nconst count = ref(0);\nconst user = ref({ name: \"Alice\", age: 30 });\n\n// 监听单个 ref\nwatch(count, (newValue, oldValue) => {\n  console.log(`Count: ${oldValue} -> ${newValue}`);\n});\n\n// 监听多个源\nwatch([count, () => user.value.name], ([newCount, newName], [oldCount, oldName]) => {\n  console.log(`Count: ${oldCount} -> ${newCount}`);\n  console.log(`Name: ${oldName} -> ${newName}`);\n});\n\n// 深层监听\nwatch(\n  user,\n  (newValue) => {\n    console.log(\"User changed:\", newValue);\n  },\n  { deep: true }\n);\n\n// 立即执行\nwatch(\n  count,\n  (value) => {\n    console.log(\"Count:\", value);\n  },\n  { immediate: true }\n);\n\n// 一次性监听\nwatch(\n  count,\n  () => {\n    console.log(\"Triggered once\");\n  },\n  { once: true }\n);\n&#x3C;/script>\n</code></pre>\n<h3>watchEffect</h3>\n<pre><code class=\"language-vue\">&#x3C;script setup lang=\"ts\">\nimport { ref, watchEffect } from \"vue\";\n\nconst count = ref(0);\nconst name = ref(\"Vue\");\n\n// 自动追踪依赖\nwatchEffect(() => {\n  console.log(`Count: ${count.value}, Name: ${name.value}`);\n});\n\n// 清理副作用\nwatchEffect((onCleanup) => {\n  const timer = setInterval(() => {\n    count.value++;\n  }, 1000);\n\n  onCleanup(() => {\n    clearInterval(timer);\n  });\n});\n\n// 停止侦听\nconst stop = watchEffect(() => {\n  console.log(count.value);\n});\n\nstop();  // 停止\n\n// 刷新时机\nwatchEffect(\n  () => {\n    // DOM 更新后执行\n  },\n  { flush: \"post\" }\n);\n&#x3C;/script>\n</code></pre>\n<h2>生命周期</h2>\n<pre><code class=\"language-vue\">&#x3C;script setup lang=\"ts\">\nimport {\n  onBeforeMount,\n  onMounted,\n  onBeforeUpdate,\n  onUpdated,\n  onBeforeUnmount,\n  onUnmounted,\n  onErrorCaptured,\n} from \"vue\";\n\nonBeforeMount(() => {\n  console.log(\"Before mount\");\n});\n\nonMounted(() => {\n  console.log(\"Mounted\");\n  // 访问 DOM\n});\n\nonBeforeUpdate(() => {\n  console.log(\"Before update\");\n});\n\nonUpdated(() => {\n  console.log(\"Updated\");\n});\n\nonBeforeUnmount(() => {\n  console.log(\"Before unmount\");\n});\n\nonUnmounted(() => {\n  console.log(\"Unmounted\");\n  // 清理工作\n});\n\nonErrorCaptured((error, instance, info) => {\n  console.error(\"Error captured:\", error);\n  return false;  // 阻止错误向上传播\n});\n&#x3C;/script>\n</code></pre>\n<h2>模板引用</h2>\n<pre><code class=\"language-vue\">&#x3C;script setup lang=\"ts\">\nimport { ref, onMounted } from \"vue\";\n\n// DOM 引用\nconst inputRef = ref&#x3C;HTMLInputElement | null>(null);\n\n// 组件引用\nconst childRef = ref&#x3C;InstanceType&#x3C;typeof ChildComponent> | null>(null);\n\nonMounted(() => {\n  inputRef.value?.focus();\n  childRef.value?.someMethod();\n});\n&#x3C;/script>\n\n&#x3C;template>\n  &#x3C;input ref=\"inputRef\" />\n  &#x3C;ChildComponent ref=\"childRef\" />\n&#x3C;/template>\n</code></pre>\n<h2>依赖注入</h2>\n<pre><code class=\"language-vue\">&#x3C;!-- 父组件 -->\n&#x3C;script setup lang=\"ts\">\nimport { provide, ref } from \"vue\";\n\nconst theme = ref(\"dark\");\nconst updateTheme = (newTheme: string) => {\n  theme.value = newTheme;\n};\n\n// 提供响应式数据\nprovide(\"theme\", theme);\nprovide(\"updateTheme\", updateTheme);\n\n// 使用 Symbol 作为 key\nconst ThemeSymbol = Symbol(\"theme\");\nprovide(ThemeSymbol, { theme, updateTheme });\n&#x3C;/script>\n\n&#x3C;!-- 子组件 -->\n&#x3C;script setup lang=\"ts\">\nimport { inject, type Ref } from \"vue\";\n\n// 注入数据\nconst theme = inject&#x3C;Ref&#x3C;string>>(\"theme\");\nconst updateTheme = inject&#x3C;(theme: string) => void>(\"updateTheme\");\n\n// 默认值\nconst theme2 = inject(\"theme\", ref(\"light\"));\n\n// 使用 Symbol\nconst ThemeSymbol = Symbol(\"theme\");\nconst themeContext = inject(ThemeSymbol);\n&#x3C;/script>\n</code></pre>\n<h2>组合函数 (Composables)</h2>\n<pre><code class=\"language-typescript\">// composables/useMouse.ts\nimport { ref, onMounted, onUnmounted } from \"vue\";\n\nexport function useMouse() {\n  const x = ref(0);\n  const y = ref(0);\n\n  function update(event: MouseEvent) {\n    x.value = event.pageX;\n    y.value = event.pageY;\n  }\n\n  onMounted(() => window.addEventListener(\"mousemove\", update));\n  onUnmounted(() => window.removeEventListener(\"mousemove\", update));\n\n  return { x, y };\n}\n\n// composables/useFetch.ts\nimport { ref, watchEffect } from \"vue\";\n\nexport function useFetch&#x3C;T>(url: string) {\n  const data = ref&#x3C;T | null>(null);\n  const error = ref&#x3C;Error | null>(null);\n  const loading = ref(true);\n\n  watchEffect(async () => {\n    loading.value = true;\n    error.value = null;\n\n    try {\n      const response = await fetch(url);\n      data.value = await response.json();\n    } catch (e) {\n      error.value = e instanceof Error ? e : new Error(\"Unknown error\");\n    } finally {\n      loading.value = false;\n    }\n  });\n\n  return { data, error, loading };\n}\n</code></pre>\n<pre><code class=\"language-vue\">&#x3C;!-- 使用组合函数 -->\n&#x3C;script setup lang=\"ts\">\nimport { useMouse } from \"@/composables/useMouse\";\nimport { useFetch } from \"@/composables/useFetch\";\n\nconst { x, y } = useMouse();\nconst { data, loading, error } = useFetch&#x3C;User[]>(\"/api/users\");\n&#x3C;/script>\n\n&#x3C;template>\n  &#x3C;div>Mouse: {{ x }}, {{ y }}&#x3C;/div>\n  &#x3C;div v-if=\"loading\">Loading...&#x3C;/div>\n  &#x3C;div v-else-if=\"error\">{{ error.message }}&#x3C;/div>\n  &#x3C;ul v-else>\n    &#x3C;li v-for=\"user in data\" :key=\"user.id\">{{ user.name }}&#x3C;/li>\n  &#x3C;/ul>\n&#x3C;/template>\n</code></pre>\n<h2>总结</h2>\n<p>Vue 组合式 API 要点：</p>\n<ol>\n<li><strong>ref/reactive</strong> - 创建响应式数据</li>\n<li><strong>computed</strong> - 计算属性，自动缓存</li>\n<li><strong>watch/watchEffect</strong> - 响应式侦听</li>\n<li><strong>生命周期钩子</strong> - onMounted 等</li>\n<li><strong>Composables</strong> - 逻辑复用的最佳实践</li>\n</ol>\n"
}