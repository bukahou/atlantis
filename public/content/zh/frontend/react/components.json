{
  "slug": "components",
  "meta": {
    "title": "React 组件开发",
    "description": "React 组件设计模式、组件通信与最佳实践",
    "order": 1,
    "tags": [
      "react",
      "components",
      "frontend",
      "patterns"
    ]
  },
  "content": "<h1>React 组件开发</h1>\n<h2>组件基础</h2>\n<p>React 组件是构建用户界面的基本单元，可以是函数组件或类组件。现代 React 推荐使用函数组件配合 Hooks。</p>\n<pre><code>组件类型\n├── 函数组件 - 简洁、Hooks 支持\n├── 类组件 - 传统方式、生命周期\n├── 高阶组件 - 逻辑复用\n├── 渲染属性 - 灵活渲染\n└── 复合组件 - 组件组合模式\n</code></pre>\n<h2>函数组件</h2>\n<h3>基础定义</h3>\n<pre><code class=\"language-tsx\">// 基本函数组件\nfunction Welcome({ name }: { name: string }) {\n  return &#x3C;h1>Hello, {name}&#x3C;/h1>;\n}\n\n// 箭头函数组件\nconst Greeting: React.FC&#x3C;{ name: string }> = ({ name }) => {\n  return &#x3C;h1>Hello, {name}&#x3C;/h1>;\n};\n\n// 带子组件\ninterface CardProps {\n  title: string;\n  children: React.ReactNode;\n}\n\nconst Card: React.FC&#x3C;CardProps> = ({ title, children }) => {\n  return (\n    &#x3C;div className=\"card\">\n      &#x3C;h2>{title}&#x3C;/h2>\n      &#x3C;div className=\"card-body\">{children}&#x3C;/div>\n    &#x3C;/div>\n  );\n};\n</code></pre>\n<h3>Props 类型</h3>\n<pre><code class=\"language-tsx\">// 完整的 Props 类型定义\ninterface ButtonProps {\n  // 必填属性\n  label: string;\n  onClick: () => void;\n\n  // 可选属性\n  variant?: \"primary\" | \"secondary\" | \"danger\";\n  size?: \"sm\" | \"md\" | \"lg\";\n  disabled?: boolean;\n  icon?: React.ReactNode;\n\n  // 样式属性\n  className?: string;\n  style?: React.CSSProperties;\n}\n\nconst Button: React.FC&#x3C;ButtonProps> = ({\n  label,\n  onClick,\n  variant = \"primary\",\n  size = \"md\",\n  disabled = false,\n  icon,\n  className,\n  style,\n}) => {\n  return (\n    &#x3C;button\n      className={`btn btn-${variant} btn-${size} ${className ?? \"\"}`}\n      onClick={onClick}\n      disabled={disabled}\n      style={style}\n    >\n      {icon &#x26;&#x26; &#x3C;span className=\"btn-icon\">{icon}&#x3C;/span>}\n      {label}\n    &#x3C;/button>\n  );\n};\n</code></pre>\n<h3>泛型组件</h3>\n<pre><code class=\"language-tsx\">// 泛型列表组件\ninterface ListProps&#x3C;T> {\n  items: T[];\n  renderItem: (item: T, index: number) => React.ReactNode;\n  keyExtractor: (item: T) => string | number;\n}\n\nfunction List&#x3C;T>({ items, renderItem, keyExtractor }: ListProps&#x3C;T>) {\n  return (\n    &#x3C;ul>\n      {items.map((item, index) => (\n        &#x3C;li key={keyExtractor(item)}>{renderItem(item, index)}&#x3C;/li>\n      ))}\n    &#x3C;/ul>\n  );\n}\n\n// 使用\n&#x3C;List\n  items={users}\n  keyExtractor={(user) => user.id}\n  renderItem={(user) => &#x3C;span>{user.name}&#x3C;/span>}\n/>\n</code></pre>\n<h2>组件模式</h2>\n<h3>复合组件</h3>\n<pre><code class=\"language-tsx\">// 复合组件模式\ninterface TabsContextType {\n  activeTab: string;\n  setActiveTab: (tab: string) => void;\n}\n\nconst TabsContext = React.createContext&#x3C;TabsContextType | null>(null);\n\nfunction Tabs({ children, defaultTab }: { children: React.ReactNode; defaultTab: string }) {\n  const [activeTab, setActiveTab] = useState(defaultTab);\n\n  return (\n    &#x3C;TabsContext.Provider value={{ activeTab, setActiveTab }}>\n      &#x3C;div className=\"tabs\">{children}&#x3C;/div>\n    &#x3C;/TabsContext.Provider>\n  );\n}\n\nfunction TabList({ children }: { children: React.ReactNode }) {\n  return &#x3C;div className=\"tab-list\">{children}&#x3C;/div>;\n}\n\nfunction Tab({ id, children }: { id: string; children: React.ReactNode }) {\n  const context = useContext(TabsContext);\n  if (!context) throw new Error(\"Tab must be used within Tabs\");\n\n  return (\n    &#x3C;button\n      className={context.activeTab === id ? \"active\" : \"\"}\n      onClick={() => context.setActiveTab(id)}\n    >\n      {children}\n    &#x3C;/button>\n  );\n}\n\nfunction TabPanel({ id, children }: { id: string; children: React.ReactNode }) {\n  const context = useContext(TabsContext);\n  if (!context) throw new Error(\"TabPanel must be used within Tabs\");\n\n  return context.activeTab === id ? &#x3C;div>{children}&#x3C;/div> : null;\n}\n\n// 组合导出\nTabs.List = TabList;\nTabs.Tab = Tab;\nTabs.Panel = TabPanel;\n\n// 使用\n&#x3C;Tabs defaultTab=\"tab1\">\n  &#x3C;Tabs.List>\n    &#x3C;Tabs.Tab id=\"tab1\">Tab 1&#x3C;/Tabs.Tab>\n    &#x3C;Tabs.Tab id=\"tab2\">Tab 2&#x3C;/Tabs.Tab>\n  &#x3C;/Tabs.List>\n  &#x3C;Tabs.Panel id=\"tab1\">Content 1&#x3C;/Tabs.Panel>\n  &#x3C;Tabs.Panel id=\"tab2\">Content 2&#x3C;/Tabs.Panel>\n&#x3C;/Tabs>\n</code></pre>\n<h3>受控与非受控</h3>\n<pre><code class=\"language-tsx\">// 受控组件\nfunction ControlledInput() {\n  const [value, setValue] = useState(\"\");\n\n  return (\n    &#x3C;input\n      value={value}\n      onChange={(e) => setValue(e.target.value)}\n    />\n  );\n}\n\n// 非受控组件\nfunction UncontrolledInput() {\n  const inputRef = useRef&#x3C;HTMLInputElement>(null);\n\n  const handleSubmit = () => {\n    console.log(inputRef.current?.value);\n  };\n\n  return &#x3C;input ref={inputRef} defaultValue=\"\" />;\n}\n\n// 同时支持受控和非受控\ninterface InputProps {\n  value?: string;\n  defaultValue?: string;\n  onChange?: (value: string) => void;\n}\n\nfunction FlexibleInput({ value, defaultValue, onChange }: InputProps) {\n  const [internalValue, setInternalValue] = useState(defaultValue ?? \"\");\n  const isControlled = value !== undefined;\n  const currentValue = isControlled ? value : internalValue;\n\n  const handleChange = (e: React.ChangeEvent&#x3C;HTMLInputElement>) => {\n    const newValue = e.target.value;\n    if (!isControlled) {\n      setInternalValue(newValue);\n    }\n    onChange?.(newValue);\n  };\n\n  return &#x3C;input value={currentValue} onChange={handleChange} />;\n}\n</code></pre>\n<h3>渲染属性</h3>\n<pre><code class=\"language-tsx\">// 渲染属性模式\ninterface MouseTrackerProps {\n  render: (position: { x: number; y: number }) => React.ReactNode;\n}\n\nfunction MouseTracker({ render }: MouseTrackerProps) {\n  const [position, setPosition] = useState({ x: 0, y: 0 });\n\n  useEffect(() => {\n    const handleMouseMove = (e: MouseEvent) => {\n      setPosition({ x: e.clientX, y: e.clientY });\n    };\n\n    window.addEventListener(\"mousemove\", handleMouseMove);\n    return () => window.removeEventListener(\"mousemove\", handleMouseMove);\n  }, []);\n\n  return &#x3C;>{render(position)}&#x3C;/>;\n}\n\n// 使用\n&#x3C;MouseTracker\n  render={({ x, y }) => (\n    &#x3C;div>Mouse position: {x}, {y}&#x3C;/div>\n  )}\n/>\n</code></pre>\n<h2>高阶组件</h2>\n<pre><code class=\"language-tsx\">// 高阶组件 (HOC)\nfunction withLoading&#x3C;P extends object>(\n  WrappedComponent: React.ComponentType&#x3C;P>\n) {\n  return function WithLoadingComponent(\n    props: P &#x26; { isLoading: boolean }\n  ) {\n    const { isLoading, ...rest } = props;\n\n    if (isLoading) {\n      return &#x3C;div>Loading...&#x3C;/div>;\n    }\n\n    return &#x3C;WrappedComponent {...(rest as P)} />;\n  };\n}\n\n// 带认证的 HOC\nfunction withAuth&#x3C;P extends object>(\n  WrappedComponent: React.ComponentType&#x3C;P>\n) {\n  return function WithAuthComponent(props: P) {\n    const { user, isLoading } = useAuth();\n\n    if (isLoading) return &#x3C;div>Loading...&#x3C;/div>;\n    if (!user) return &#x3C;Navigate to=\"/login\" />;\n\n    return &#x3C;WrappedComponent {...props} />;\n  };\n}\n\n// 使用\nconst ProtectedDashboard = withAuth(Dashboard);\n</code></pre>\n<h2>组件通信</h2>\n<h3>Props 传递</h3>\n<pre><code class=\"language-tsx\">// 父传子\nfunction Parent() {\n  const [count, setCount] = useState(0);\n\n  return (\n    &#x3C;Child\n      count={count}\n      onIncrement={() => setCount(c => c + 1)}\n    />\n  );\n}\n\nfunction Child({ count, onIncrement }: {\n  count: number;\n  onIncrement: () => void;\n}) {\n  return (\n    &#x3C;div>\n      &#x3C;span>{count}&#x3C;/span>\n      &#x3C;button onClick={onIncrement}>+&#x3C;/button>\n    &#x3C;/div>\n  );\n}\n</code></pre>\n<h3>Context 共享</h3>\n<pre><code class=\"language-tsx\">// 创建 Context\ninterface ThemeContextType {\n  theme: \"light\" | \"dark\";\n  toggleTheme: () => void;\n}\n\nconst ThemeContext = createContext&#x3C;ThemeContextType | undefined>(undefined);\n\n// Provider\nfunction ThemeProvider({ children }: { children: React.ReactNode }) {\n  const [theme, setTheme] = useState&#x3C;\"light\" | \"dark\">(\"light\");\n\n  const toggleTheme = useCallback(() => {\n    setTheme(t => t === \"light\" ? \"dark\" : \"light\");\n  }, []);\n\n  return (\n    &#x3C;ThemeContext.Provider value={{ theme, toggleTheme }}>\n      {children}\n    &#x3C;/ThemeContext.Provider>\n  );\n}\n\n// 自定义 Hook\nfunction useTheme() {\n  const context = useContext(ThemeContext);\n  if (!context) {\n    throw new Error(\"useTheme must be used within ThemeProvider\");\n  }\n  return context;\n}\n\n// 使用\nfunction ThemedButton() {\n  const { theme, toggleTheme } = useTheme();\n  return (\n    &#x3C;button onClick={toggleTheme}>\n      Current: {theme}\n    &#x3C;/button>\n  );\n}\n</code></pre>\n<h2>性能优化</h2>\n<h3>React.memo</h3>\n<pre><code class=\"language-tsx\">// 避免不必要的重渲染\nconst ExpensiveComponent = React.memo(function ExpensiveComponent({\n  data,\n  onUpdate,\n}: {\n  data: Data;\n  onUpdate: () => void;\n}) {\n  // 复杂渲染逻辑\n  return &#x3C;div>{/* ... */}&#x3C;/div>;\n});\n\n// 自定义比较函数\nconst OptimizedList = React.memo(\n  function OptimizedList({ items }: { items: Item[] }) {\n    return (\n      &#x3C;ul>\n        {items.map(item => &#x3C;li key={item.id}>{item.name}&#x3C;/li>)}\n      &#x3C;/ul>\n    );\n  },\n  (prevProps, nextProps) => {\n    return prevProps.items.length === nextProps.items.length;\n  }\n);\n</code></pre>\n<h3>useMemo 和 useCallback</h3>\n<pre><code class=\"language-tsx\">function SearchResults({ query, items }: { query: string; items: Item[] }) {\n  // 缓存计算结果\n  const filteredItems = useMemo(() => {\n    return items.filter(item =>\n      item.name.toLowerCase().includes(query.toLowerCase())\n    );\n  }, [items, query]);\n\n  // 缓存回调函数\n  const handleItemClick = useCallback((id: string) => {\n    console.log(\"Clicked:\", id);\n  }, []);\n\n  return (\n    &#x3C;ul>\n      {filteredItems.map(item => (\n        &#x3C;li key={item.id} onClick={() => handleItemClick(item.id)}>\n          {item.name}\n        &#x3C;/li>\n      ))}\n    &#x3C;/ul>\n  );\n}\n</code></pre>\n<h2>总结</h2>\n<p>React 组件开发要点：</p>\n<ol>\n<li><strong>函数组件</strong> - 现代 React 的首选方式</li>\n<li><strong>类型安全</strong> - TypeScript 增强可维护性</li>\n<li><strong>组件模式</strong> - 复合组件、HOC、渲染属性</li>\n<li><strong>状态管理</strong> - 受控/非受控、Context</li>\n<li><strong>性能优化</strong> - memo、useMemo、useCallback</li>\n</ol>\n"
}