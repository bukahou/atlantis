{
  "slug": "redis-mq",
  "meta": {
    "title": "Redis 消息队列",
    "description": "Redis 实现消息队列、发布订阅与 Stream 数据结构",
    "order": 3,
    "tags": [
      "mq",
      "redis",
      "pubsub",
      "stream"
    ]
  },
  "content": "<h1>Redis 消息队列</h1>\n<h2>Redis 消息模式概述</h2>\n<p>Redis 提供多种消息队列实现方式，适用于不同场景的消息传递需求。</p>\n<pre><code>Redis 消息模式\n├── List - 简单队列 (LPUSH/RPOP)\n├── Pub/Sub - 发布订阅\n├── Stream - 持久化消息流 (推荐)\n└── Sorted Set - 延迟队列\n</code></pre>\n<h2>List 队列</h2>\n<h3>基本队列</h3>\n<pre><code class=\"language-go\">import \"github.com/redis/go-redis/v9\"\n\n// 生产者 - 入队\nfunc Produce(rdb *redis.Client, queue string, message string) error {\n    return rdb.LPush(ctx, queue, message).Err()\n}\n\n// 消费者 - 出队\nfunc Consume(rdb *redis.Client, queue string) (string, error) {\n    return rdb.RPop(ctx, queue).Result()\n}\n\n// 阻塞消费\nfunc BlockingConsume(rdb *redis.Client, queue string, timeout time.Duration) (string, error) {\n    result, err := rdb.BRPop(ctx, timeout, queue).Result()\n    if err != nil {\n        return \"\", err\n    }\n    return result[1], nil\n}\n</code></pre>\n<h3>可靠队列</h3>\n<pre><code class=\"language-go\">// RPOPLPUSH 实现可靠消费\nfunc ReliableConsume(rdb *redis.Client, source, processing string) (string, error) {\n    // 原子移动到处理队列\n    return rdb.RPopLPush(ctx, source, processing).Result()\n}\n\n// 确认完成\nfunc Acknowledge(rdb *redis.Client, processing, message string) error {\n    return rdb.LRem(ctx, processing, 1, message).Err()\n}\n\n// 重新入队失败消息\nfunc Requeue(rdb *redis.Client, processing, source string) error {\n    for {\n        msg, err := rdb.RPopLPush(ctx, processing, source).Result()\n        if err == redis.Nil {\n            break\n        }\n        if err != nil {\n            return err\n        }\n        fmt.Println(\"Requeued:\", msg)\n    }\n    return nil\n}\n</code></pre>\n<h2>Pub/Sub</h2>\n<h3>发布订阅</h3>\n<pre><code class=\"language-go\">// 发布者\nfunc Publish(rdb *redis.Client, channel, message string) error {\n    return rdb.Publish(ctx, channel, message).Err()\n}\n\n// 订阅者\nfunc Subscribe(rdb *redis.Client, channels ...string) {\n    pubsub := rdb.Subscribe(ctx, channels...)\n    defer pubsub.Close()\n\n    // 接收消息\n    ch := pubsub.Channel()\n    for msg := range ch {\n        fmt.Printf(\"Channel: %s, Message: %s\\n\", msg.Channel, msg.Payload)\n    }\n}\n\n// 模式订阅\nfunc PSubscribe(rdb *redis.Client, patterns ...string) {\n    pubsub := rdb.PSubscribe(ctx, patterns...)\n    defer pubsub.Close()\n\n    // 订阅 order.* 模式\n    ch := pubsub.Channel()\n    for msg := range ch {\n        fmt.Printf(\"Pattern: %s, Channel: %s, Message: %s\\n\",\n            msg.Pattern, msg.Channel, msg.Payload)\n    }\n}\n</code></pre>\n<h3>Pub/Sub 限制</h3>\n<pre><code>注意事项\n├── 无持久化 - 消息发送即丢失\n├── 无确认机制 - 不保证送达\n├── 无消费者组 - 每个订阅者收到所有消息\n└── 适用场景 - 实时通知、广播\n</code></pre>\n<h2>Stream (推荐)</h2>\n<h3>Stream 基础</h3>\n<pre><code class=\"language-go\">// 添加消息\nfunc AddMessage(rdb *redis.Client, stream string, values map[string]interface{}) (string, error) {\n    return rdb.XAdd(ctx, &#x26;redis.XAddArgs{\n        Stream: stream,\n        MaxLen: 10000,      // 最大长度\n        Approx: true,       // 近似修剪\n        ID:     \"*\",        // 自动生成 ID\n        Values: values,\n    }).Result()\n}\n\n// 读取消息\nfunc ReadMessages(rdb *redis.Client, stream, lastID string, count int64) ([]redis.XMessage, error) {\n    streams, err := rdb.XRead(ctx, &#x26;redis.XReadArgs{\n        Streams: []string{stream, lastID},\n        Count:   count,\n        Block:   0, // 阻塞等待\n    }).Result()\n\n    if err != nil {\n        return nil, err\n    }\n    return streams[0].Messages, nil\n}\n</code></pre>\n<h3>消费者组</h3>\n<pre><code class=\"language-go\">// 创建消费者组\nfunc CreateGroup(rdb *redis.Client, stream, group string) error {\n    return rdb.XGroupCreateMkStream(ctx, stream, group, \"0\").Err()\n}\n\n// 消费者组读取\nfunc GroupRead(rdb *redis.Client, stream, group, consumer string) ([]redis.XMessage, error) {\n    streams, err := rdb.XReadGroup(ctx, &#x26;redis.XReadGroupArgs{\n        Group:    group,\n        Consumer: consumer,\n        Streams:  []string{stream, \">\"},\n        Count:    10,\n        Block:    5 * time.Second,\n    }).Result()\n\n    if err != nil {\n        return nil, err\n    }\n    if len(streams) == 0 {\n        return nil, nil\n    }\n    return streams[0].Messages, nil\n}\n\n// 确认消息\nfunc AckMessage(rdb *redis.Client, stream, group string, ids ...string) error {\n    return rdb.XAck(ctx, stream, group, ids...).Err()\n}\n\n// 获取待处理消息\nfunc GetPending(rdb *redis.Client, stream, group string) (*redis.XPending, error) {\n    return rdb.XPending(ctx, stream, group).Result()\n}\n\n// 认领超时消息\nfunc ClaimMessages(rdb *redis.Client, stream, group, consumer string, minIdle time.Duration) ([]redis.XMessage, error) {\n    return rdb.XAutoClaim(ctx, &#x26;redis.XAutoClaimArgs{\n        Stream:   stream,\n        Group:    group,\n        Consumer: consumer,\n        MinIdle:  minIdle,\n        Start:    \"0-0\",\n        Count:    10,\n    }).Val(), nil\n}\n</code></pre>\n<h3>完整消费者示例</h3>\n<pre><code class=\"language-go\">type StreamConsumer struct {\n    rdb      *redis.Client\n    stream   string\n    group    string\n    consumer string\n}\n\nfunc (c *StreamConsumer) Run(handler func(msg redis.XMessage) error) {\n    for {\n        // 读取新消息\n        messages, err := c.rdb.XReadGroup(ctx, &#x26;redis.XReadGroupArgs{\n            Group:    c.group,\n            Consumer: c.consumer,\n            Streams:  []string{c.stream, \">\"},\n            Count:    10,\n            Block:    5 * time.Second,\n        }).Result()\n\n        if err != nil {\n            continue\n        }\n\n        for _, stream := range messages {\n            for _, msg := range stream.Messages {\n                // 处理消息\n                if err := handler(msg); err != nil {\n                    // 处理失败，消息保留在 pending\n                    continue\n                }\n                // 确认消息\n                c.rdb.XAck(ctx, c.stream, c.group, msg.ID)\n            }\n        }\n    }\n}\n\n// 使用\nconsumer := &#x26;StreamConsumer{\n    rdb:      rdb,\n    stream:   \"orders\",\n    group:    \"order-processor\",\n    consumer: \"consumer-1\",\n}\n\nconsumer.Run(func(msg redis.XMessage) error {\n    fmt.Printf(\"Processing: %v\\n\", msg.Values)\n    return nil\n})\n</code></pre>\n<h2>延迟队列</h2>\n<h3>Sorted Set 实现</h3>\n<pre><code class=\"language-go\">// 添加延迟任务\nfunc AddDelayedTask(rdb *redis.Client, queue, task string, delay time.Duration) error {\n    score := float64(time.Now().Add(delay).Unix())\n    return rdb.ZAdd(ctx, queue, redis.Z{\n        Score:  score,\n        Member: task,\n    }).Err()\n}\n\n// 获取到期任务\nfunc GetDueTasks(rdb *redis.Client, queue string) ([]string, error) {\n    now := float64(time.Now().Unix())\n    return rdb.ZRangeByScore(ctx, queue, &#x26;redis.ZRangeBy{\n        Min: \"-inf\",\n        Max: fmt.Sprintf(\"%f\", now),\n    }).Result()\n}\n\n// 处理延迟任务\nfunc ProcessDelayedTasks(rdb *redis.Client, queue string) {\n    for {\n        // 原子获取并删除\n        result, err := rdb.ZPopMin(ctx, queue, 1).Result()\n        if err != nil || len(result) == 0 {\n            time.Sleep(100 * time.Millisecond)\n            continue\n        }\n\n        task := result[0]\n        score := int64(task.Score)\n\n        // 检查是否到期\n        if score > time.Now().Unix() {\n            // 未到期，放回\n            rdb.ZAdd(ctx, queue, task)\n            time.Sleep(100 * time.Millisecond)\n            continue\n        }\n\n        // 处理任务\n        processTask(task.Member.(string))\n    }\n}\n</code></pre>\n<h2>总结</h2>\n<p>Redis 消息队列要点：</p>\n<ol>\n<li><strong>List</strong> - 简单队列，适合基础场景</li>\n<li><strong>Pub/Sub</strong> - 实时广播，无持久化</li>\n<li><strong>Stream</strong> - 推荐方案，支持消费者组</li>\n<li><strong>延迟队列</strong> - Sorted Set 实现</li>\n<li><strong>选型</strong> - 按可靠性和功能需求选择</li>\n</ol>\n"
}