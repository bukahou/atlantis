{
  "slug": "grpc",
  "meta": {
    "title": "gRPC",
    "description": "gRPC 协议、Protocol Buffers 与服务间通信",
    "order": 3,
    "tags": [
      "api",
      "grpc",
      "protobuf",
      "rpc"
    ]
  },
  "content": "<h1>gRPC</h1>\n<h2>gRPC 概述</h2>\n<p>gRPC 是 Google 开发的高性能 RPC 框架，使用 Protocol Buffers 作为接口定义语言和消息序列化格式。</p>\n<pre><code>gRPC 特点\n├── 高性能 - 二进制序列化、HTTP/2\n├── 强类型 - Protocol Buffers 定义\n├── 多语言 - 支持多种编程语言\n├── 流式传输 - 支持双向流\n└── 代码生成 - 自动生成客户端和服务端代码\n</code></pre>\n<h2>Protocol Buffers</h2>\n<h3>基本语法</h3>\n<pre><code class=\"language-protobuf\">// user.proto\nsyntax = \"proto3\";\n\npackage user.v1;\n\noption go_package = \"github.com/example/user/v1\";\n\n// 消息定义\nmessage User {\n  string id = 1;\n  string name = 2;\n  string email = 3;\n  UserRole role = 4;\n  repeated string tags = 5;\n  optional string bio = 6;\n  google.protobuf.Timestamp created_at = 7;\n}\n\n// 枚举\nenum UserRole {\n  USER_ROLE_UNSPECIFIED = 0;\n  USER_ROLE_ADMIN = 1;\n  USER_ROLE_USER = 2;\n  USER_ROLE_GUEST = 3;\n}\n\n// 嵌套消息\nmessage Address {\n  string street = 1;\n  string city = 2;\n  string country = 3;\n}\n\nmessage UserProfile {\n  User user = 1;\n  Address address = 2;\n}\n</code></pre>\n<h3>标量类型</h3>\n<pre><code class=\"language-protobuf\">// 数值类型\nint32, int64       // 有符号整数\nuint32, uint64     // 无符号整数\nsint32, sint64     // 有符号 (ZigZag 编码)\nfixed32, fixed64   // 固定长度无符号\nsfixed32, sfixed64 // 固定长度有符号\nfloat, double      // 浮点数\n\n// 其他类型\nbool               // 布尔值\nstring             // UTF-8 字符串\nbytes              // 任意字节序列\n</code></pre>\n<h3>服务定义</h3>\n<pre><code class=\"language-protobuf\">// 服务定义\nservice UserService {\n  // 一元 RPC\n  rpc GetUser(GetUserRequest) returns (GetUserResponse);\n  rpc CreateUser(CreateUserRequest) returns (CreateUserResponse);\n  rpc UpdateUser(UpdateUserRequest) returns (UpdateUserResponse);\n  rpc DeleteUser(DeleteUserRequest) returns (DeleteUserResponse);\n\n  // 服务端流\n  rpc ListUsers(ListUsersRequest) returns (stream User);\n\n  // 客户端流\n  rpc CreateUsers(stream CreateUserRequest) returns (CreateUsersResponse);\n\n  // 双向流\n  rpc Chat(stream ChatMessage) returns (stream ChatMessage);\n}\n\n// 请求消息\nmessage GetUserRequest {\n  string id = 1;\n}\n\nmessage GetUserResponse {\n  User user = 1;\n}\n\nmessage ListUsersRequest {\n  int32 page_size = 1;\n  string page_token = 2;\n  UserFilter filter = 3;\n}\n\nmessage UserFilter {\n  optional UserRole role = 1;\n  optional string name_contains = 2;\n}\n</code></pre>\n<h2>服务实现</h2>\n<h3>Go 服务端</h3>\n<pre><code class=\"language-go\">// server.go\npackage main\n\nimport (\n    \"context\"\n    \"log\"\n    \"net\"\n\n    \"google.golang.org/grpc\"\n    pb \"github.com/example/user/v1\"\n)\n\ntype userServer struct {\n    pb.UnimplementedUserServiceServer\n    users map[string]*pb.User\n}\n\nfunc (s *userServer) GetUser(ctx context.Context, req *pb.GetUserRequest) (*pb.GetUserResponse, error) {\n    user, ok := s.users[req.Id]\n    if !ok {\n        return nil, status.Errorf(codes.NotFound, \"user not found: %s\", req.Id)\n    }\n    return &#x26;pb.GetUserResponse{User: user}, nil\n}\n\nfunc (s *userServer) CreateUser(ctx context.Context, req *pb.CreateUserRequest) (*pb.CreateUserResponse, error) {\n    user := &#x26;pb.User{\n        Id:    uuid.New().String(),\n        Name:  req.Name,\n        Email: req.Email,\n    }\n    s.users[user.Id] = user\n    return &#x26;pb.CreateUserResponse{User: user}, nil\n}\n\n// 服务端流\nfunc (s *userServer) ListUsers(req *pb.ListUsersRequest, stream pb.UserService_ListUsersServer) error {\n    for _, user := range s.users {\n        if err := stream.Send(user); err != nil {\n            return err\n        }\n    }\n    return nil\n}\n\nfunc main() {\n    lis, _ := net.Listen(\"tcp\", \":50051\")\n    grpcServer := grpc.NewServer()\n    pb.RegisterUserServiceServer(grpcServer, &#x26;userServer{\n        users: make(map[string]*pb.User),\n    })\n    log.Fatal(grpcServer.Serve(lis))\n}\n</code></pre>\n<h3>Go 客户端</h3>\n<pre><code class=\"language-go\">// client.go\npackage main\n\nimport (\n    \"context\"\n    \"io\"\n    \"log\"\n\n    \"google.golang.org/grpc\"\n    \"google.golang.org/grpc/credentials/insecure\"\n    pb \"github.com/example/user/v1\"\n)\n\nfunc main() {\n    conn, _ := grpc.Dial(\"localhost:50051\",\n        grpc.WithTransportCredentials(insecure.NewCredentials()))\n    defer conn.Close()\n\n    client := pb.NewUserServiceClient(conn)\n\n    // 一元调用\n    resp, err := client.GetUser(context.Background(), &#x26;pb.GetUserRequest{\n        Id: \"123\",\n    })\n    if err != nil {\n        log.Fatal(err)\n    }\n    log.Printf(\"User: %v\", resp.User)\n\n    // 服务端流\n    stream, _ := client.ListUsers(context.Background(), &#x26;pb.ListUsersRequest{})\n    for {\n        user, err := stream.Recv()\n        if err == io.EOF {\n            break\n        }\n        log.Printf(\"User: %v\", user)\n    }\n}\n</code></pre>\n<h2>流式传输</h2>\n<h3>四种模式</h3>\n<pre><code>1. 一元 RPC\n   Client -> Server: Request\n   Server -> Client: Response\n\n2. 服务端流\n   Client -> Server: Request\n   Server -> Client: Response1, Response2, ...\n\n3. 客户端流\n   Client -> Server: Request1, Request2, ...\n   Server -> Client: Response\n\n4. 双向流\n   Client &#x3C;-> Server: 双向消息流\n</code></pre>\n<h3>双向流示例</h3>\n<pre><code class=\"language-go\">// 服务端\nfunc (s *chatServer) Chat(stream pb.ChatService_ChatServer) error {\n    for {\n        msg, err := stream.Recv()\n        if err == io.EOF {\n            return nil\n        }\n        // 处理消息\n        response := &#x26;pb.ChatMessage{\n            Content: \"Echo: \" + msg.Content,\n        }\n        if err := stream.Send(response); err != nil {\n            return err\n        }\n    }\n}\n\n// 客户端\nstream, _ := client.Chat(context.Background())\ngo func() {\n    for {\n        msg, err := stream.Recv()\n        if err == io.EOF {\n            return\n        }\n        log.Printf(\"Received: %s\", msg.Content)\n    }\n}()\n\nstream.Send(&#x26;pb.ChatMessage{Content: \"Hello\"})\nstream.Send(&#x26;pb.ChatMessage{Content: \"World\"})\nstream.CloseSend()\n</code></pre>\n<h2>拦截器</h2>\n<pre><code class=\"language-go\">// 一元拦截器\nfunc loggingInterceptor(\n    ctx context.Context,\n    req interface{},\n    info *grpc.UnaryServerInfo,\n    handler grpc.UnaryHandler,\n) (interface{}, error) {\n    start := time.Now()\n    resp, err := handler(ctx, req)\n    log.Printf(\"Method: %s, Duration: %v, Error: %v\",\n        info.FullMethod, time.Since(start), err)\n    return resp, err\n}\n\n// 流拦截器\nfunc streamInterceptor(\n    srv interface{},\n    ss grpc.ServerStream,\n    info *grpc.StreamServerInfo,\n    handler grpc.StreamHandler,\n) error {\n    log.Printf(\"Stream started: %s\", info.FullMethod)\n    return handler(srv, ss)\n}\n\n// 注册拦截器\nserver := grpc.NewServer(\n    grpc.UnaryInterceptor(loggingInterceptor),\n    grpc.StreamInterceptor(streamInterceptor),\n)\n</code></pre>\n<h2>错误处理</h2>\n<pre><code class=\"language-go\">import \"google.golang.org/grpc/codes\"\nimport \"google.golang.org/grpc/status\"\n\n// 返回错误\nfunc (s *server) GetUser(ctx context.Context, req *pb.GetUserRequest) (*pb.GetUserResponse, error) {\n    if req.Id == \"\" {\n        return nil, status.Errorf(codes.InvalidArgument, \"id is required\")\n    }\n\n    user, err := s.db.GetUser(req.Id)\n    if err != nil {\n        if errors.Is(err, sql.ErrNoRows) {\n            return nil, status.Errorf(codes.NotFound, \"user not found\")\n        }\n        return nil, status.Errorf(codes.Internal, \"internal error\")\n    }\n\n    return &#x26;pb.GetUserResponse{User: user}, nil\n}\n\n// 处理错误\nresp, err := client.GetUser(ctx, req)\nif err != nil {\n    st, ok := status.FromError(err)\n    if ok {\n        switch st.Code() {\n        case codes.NotFound:\n            // 处理 NotFound\n        case codes.InvalidArgument:\n            // 处理参数错误\n        }\n    }\n}\n</code></pre>\n<h2>总结</h2>\n<p>gRPC 要点：</p>\n<ol>\n<li><strong>Protocol Buffers</strong> - 强类型接口定义</li>\n<li><strong>高性能</strong> - 二进制序列化 + HTTP/2</li>\n<li><strong>流式传输</strong> - 四种 RPC 模式</li>\n<li><strong>拦截器</strong> - 横切关注点处理</li>\n<li><strong>代码生成</strong> - 多语言支持</li>\n</ol>\n"
}