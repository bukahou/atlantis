{
  "slug": "discovery",
  "meta": {
    "title": "服务发现",
    "description": "微服务服务发现机制、注册中心与负载均衡",
    "order": 2,
    "tags": [
      "microservices",
      "discovery",
      "consul",
      "etcd"
    ]
  },
  "content": "<h1>服务发现</h1>\n<h2>服务发现概述</h2>\n<p>服务发现允许服务在分布式环境中动态找到其他服务，是微服务架构的核心基础设施。</p>\n<pre><code>服务发现流程\n├── 服务注册 - 服务启动时注册\n├── 健康检查 - 定期检测服务状态\n├── 服务查询 - 客户端获取服务列表\n├── 负载均衡 - 选择目标实例\n└── 服务注销 - 服务下线时移除\n</code></pre>\n<h2>注册中心</h2>\n<h3>Consul</h3>\n<pre><code class=\"language-hcl\"># Consul 服务定义\nservice {\n  name = \"user-service\"\n  id   = \"user-service-1\"\n  port = 8080\n  tags = [\"v1\", \"primary\"]\n\n  check {\n    http     = \"http://localhost:8080/health\"\n    interval = \"10s\"\n    timeout  = \"3s\"\n  }\n\n  meta {\n    version = \"1.0.0\"\n    region  = \"us-east-1\"\n  }\n}\n</code></pre>\n<pre><code class=\"language-go\">// Go 服务注册\nimport \"github.com/hashicorp/consul/api\"\n\nfunc RegisterService(client *api.Client) error {\n    registration := &#x26;api.AgentServiceRegistration{\n        ID:      \"user-service-1\",\n        Name:    \"user-service\",\n        Port:    8080,\n        Address: \"192.168.1.100\",\n        Tags:    []string{\"v1\", \"primary\"},\n        Check: &#x26;api.AgentServiceCheck{\n            HTTP:                           \"http://192.168.1.100:8080/health\",\n            Interval:                       \"10s\",\n            Timeout:                        \"3s\",\n            DeregisterCriticalServiceAfter: \"1m\",\n        },\n    }\n    return client.Agent().ServiceRegister(registration)\n}\n\n// 服务发现\nfunc DiscoverService(client *api.Client, serviceName string) ([]*api.ServiceEntry, error) {\n    services, _, err := client.Health().Service(serviceName, \"\", true, nil)\n    return services, err\n}\n</code></pre>\n<h3>etcd</h3>\n<pre><code class=\"language-go\">// etcd 服务注册\nimport clientv3 \"go.etcd.io/etcd/client/v3\"\n\nfunc RegisterService(client *clientv3.Client, serviceName, addr string) error {\n    ctx := context.Background()\n\n    // 创建租约\n    lease, _ := client.Grant(ctx, 10)\n\n    // 注册服务\n    key := fmt.Sprintf(\"/services/%s/%s\", serviceName, addr)\n    _, err := client.Put(ctx, key, addr, clientv3.WithLease(lease.ID))\n    if err != nil {\n        return err\n    }\n\n    // 保持租约\n    ch, _ := client.KeepAlive(ctx, lease.ID)\n    go func() {\n        for range ch {\n            // 租约续期\n        }\n    }()\n\n    return nil\n}\n\n// 服务发现\nfunc DiscoverService(client *clientv3.Client, serviceName string) ([]string, error) {\n    ctx := context.Background()\n    prefix := fmt.Sprintf(\"/services/%s/\", serviceName)\n    resp, err := client.Get(ctx, prefix, clientv3.WithPrefix())\n    if err != nil {\n        return nil, err\n    }\n\n    var addrs []string\n    for _, kv := range resp.Kvs {\n        addrs = append(addrs, string(kv.Value))\n    }\n    return addrs, nil\n}\n\n// 监听变化\nfunc WatchService(client *clientv3.Client, serviceName string) {\n    prefix := fmt.Sprintf(\"/services/%s/\", serviceName)\n    watchChan := client.Watch(context.Background(), prefix, clientv3.WithPrefix())\n\n    for watchResp := range watchChan {\n        for _, event := range watchResp.Events {\n            switch event.Type {\n            case clientv3.EventTypePut:\n                fmt.Println(\"Service added:\", string(event.Kv.Value))\n            case clientv3.EventTypeDelete:\n                fmt.Println(\"Service removed:\", string(event.Kv.Key))\n            }\n        }\n    }\n}\n</code></pre>\n<h3>Kubernetes 服务发现</h3>\n<pre><code class=\"language-yaml\"># Service 定义\napiVersion: v1\nkind: Service\nmetadata:\n  name: user-service\nspec:\n  selector:\n    app: user-service\n  ports:\n    - port: 80\n      targetPort: 8080\n  type: ClusterIP\n---\n# Endpoints 自动管理\n# 通过 DNS 访问: user-service.default.svc.cluster.local\n</code></pre>\n<pre><code class=\"language-go\">// 在 K8s 中发现服务\n// 1. DNS 方式\nresp, _ := http.Get(\"http://user-service:80/api/users\")\n\n// 2. API 方式\nimport \"k8s.io/client-go/kubernetes\"\n\nfunc GetEndpoints(clientset *kubernetes.Clientset, namespace, serviceName string) ([]string, error) {\n    endpoints, err := clientset.CoreV1().Endpoints(namespace).Get(\n        context.Background(), serviceName, metav1.GetOptions{})\n    if err != nil {\n        return nil, err\n    }\n\n    var addrs []string\n    for _, subset := range endpoints.Subsets {\n        for _, addr := range subset.Addresses {\n            for _, port := range subset.Ports {\n                addrs = append(addrs, fmt.Sprintf(\"%s:%d\", addr.IP, port.Port))\n            }\n        }\n    }\n    return addrs, nil\n}\n</code></pre>\n<h2>负载均衡</h2>\n<h3>负载均衡策略</h3>\n<pre><code class=\"language-go\">// 轮询\ntype RoundRobin struct {\n    instances []string\n    current   int\n    mu        sync.Mutex\n}\n\nfunc (r *RoundRobin) Next() string {\n    r.mu.Lock()\n    defer r.mu.Unlock()\n    instance := r.instances[r.current]\n    r.current = (r.current + 1) % len(r.instances)\n    return instance\n}\n\n// 加权轮询\ntype WeightedRoundRobin struct {\n    instances []Instance\n    current   int\n}\n\ntype Instance struct {\n    Addr   string\n    Weight int\n}\n\n// 随机\nfunc Random(instances []string) string {\n    return instances[rand.Intn(len(instances))]\n}\n\n// 最少连接\ntype LeastConnections struct {\n    instances map[string]*atomic.Int32\n}\n\nfunc (lc *LeastConnections) Next() string {\n    var minAddr string\n    var minConn int32 = math.MaxInt32\n    for addr, conn := range lc.instances {\n        if conn.Load() &#x3C; minConn {\n            minAddr = addr\n            minConn = conn.Load()\n        }\n    }\n    lc.instances[minAddr].Add(1)\n    return minAddr\n}\n\n// 一致性哈希\ntype ConsistentHash struct {\n    ring     map[uint32]string\n    sortedKeys []uint32\n    replicas int\n}\n\nfunc (ch *ConsistentHash) Get(key string) string {\n    hash := crc32.ChecksumIEEE([]byte(key))\n    idx := sort.Search(len(ch.sortedKeys), func(i int) bool {\n        return ch.sortedKeys[i] >= hash\n    })\n    if idx == len(ch.sortedKeys) {\n        idx = 0\n    }\n    return ch.ring[ch.sortedKeys[idx]]\n}\n</code></pre>\n<h2>健康检查</h2>\n<pre><code class=\"language-go\">// HTTP 健康检查\nfunc healthHandler(w http.ResponseWriter, r *http.Request) {\n    // 检查依赖\n    if err := checkDatabase(); err != nil {\n        w.WriteHeader(http.StatusServiceUnavailable)\n        json.NewEncoder(w).Encode(map[string]string{\n            \"status\": \"unhealthy\",\n            \"error\":  err.Error(),\n        })\n        return\n    }\n\n    w.WriteHeader(http.StatusOK)\n    json.NewEncoder(w).Encode(map[string]string{\n        \"status\": \"healthy\",\n    })\n}\n\n// 就绪探针\nfunc readinessHandler(w http.ResponseWriter, r *http.Request) {\n    if !isReady {\n        w.WriteHeader(http.StatusServiceUnavailable)\n        return\n    }\n    w.WriteHeader(http.StatusOK)\n}\n\n// 存活探针\nfunc livenessHandler(w http.ResponseWriter, r *http.Request) {\n    w.WriteHeader(http.StatusOK)\n}\n</code></pre>\n<pre><code class=\"language-yaml\"># Kubernetes 探针配置\nspec:\n  containers:\n    - name: app\n      livenessProbe:\n        httpGet:\n          path: /healthz\n          port: 8080\n        initialDelaySeconds: 15\n        periodSeconds: 10\n      readinessProbe:\n        httpGet:\n          path: /ready\n          port: 8080\n        initialDelaySeconds: 5\n        periodSeconds: 5\n</code></pre>\n<h2>总结</h2>\n<p>服务发现要点：</p>\n<ol>\n<li><strong>注册中心</strong> - Consul、etcd、K8s DNS</li>\n<li><strong>健康检查</strong> - HTTP、TCP、gRPC</li>\n<li><strong>负载均衡</strong> - 轮询、随机、一致性哈希</li>\n<li><strong>服务监听</strong> - 实时感知服务变化</li>\n<li><strong>优雅下线</strong> - 注销与流量排空</li>\n</ol>\n"
}