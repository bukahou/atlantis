{
  "slug": "redis",
  "meta": {
    "title": "Redis",
    "description": "Redis 内存数据库、数据结构与缓存策略",
    "order": 2,
    "tags": [
      "database",
      "redis",
      "nosql",
      "cache"
    ]
  },
  "content": "<h1>Redis</h1>\n<h2>Redis 概述</h2>\n<p>Redis 是高性能内存键值数据库，支持丰富的数据结构，广泛用于缓存、会话存储和实时应用。</p>\n<pre><code>Redis 特性\n├── 内存存储 - 极高性能\n├── 丰富数据结构 - String, Hash, List, Set, ZSet\n├── 持久化 - RDB, AOF\n├── 集群 - 主从复制, 哨兵, Cluster\n├── 事务 - MULTI/EXEC\n└── Lua 脚本 - 原子操作\n</code></pre>\n<h2>数据结构</h2>\n<h3>String</h3>\n<pre><code class=\"language-redis\"># 基础操作\nSET key value\nGET key\nDEL key\n\n# 过期时间\nSET key value EX 3600\nSETEX key 3600 value\nTTL key\n\n# 数值操作\nINCR counter\nINCRBY counter 10\nDECR counter\n\n# 批量操作\nMSET k1 v1 k2 v2\nMGET k1 k2\n</code></pre>\n<h3>Hash</h3>\n<pre><code class=\"language-redis\"># 哈希操作\nHSET user:1 name \"Alice\" age 28\nHGET user:1 name\nHGETALL user:1\nHDEL user:1 age\n\n# 批量操作\nHMSET user:1 name \"Alice\" email \"alice@example.com\"\nHMGET user:1 name email\n\n# 数值操作\nHINCRBY user:1 age 1\n</code></pre>\n<h3>List</h3>\n<pre><code class=\"language-redis\"># 列表操作\nLPUSH queue item1 item2\nRPUSH queue item3\nLPOP queue\nRPOP queue\n\n# 阻塞操作\nBLPOP queue 10\nBRPOP queue 10\n\n# 范围查询\nLRANGE queue 0 -1\nLLEN queue\n</code></pre>\n<h3>Set</h3>\n<pre><code class=\"language-redis\"># 集合操作\nSADD tags golang python rust\nSMEMBERS tags\nSISMEMBER tags golang\nSREM tags python\n\n# 集合运算\nSINTER set1 set2       # 交集\nSUNION set1 set2       # 并集\nSDIFF set1 set2        # 差集\n</code></pre>\n<h3>Sorted Set</h3>\n<pre><code class=\"language-redis\"># 有序集合\nZADD leaderboard 100 \"player1\" 200 \"player2\"\nZSCORE leaderboard player1\nZRANK leaderboard player1\n\n# 范围查询\nZRANGE leaderboard 0 -1 WITHSCORES\nZREVRANGE leaderboard 0 9 WITHSCORES\nZRANGEBYSCORE leaderboard 100 200\n\n# 更新分数\nZINCRBY leaderboard 50 player1\n</code></pre>\n<h2>Go 客户端</h2>\n<pre><code class=\"language-go\">import \"github.com/redis/go-redis/v9\"\n\n// 连接\nrdb := redis.NewClient(&#x26;redis.Options{\n    Addr:     \"localhost:6379\",\n    Password: \"\",\n    DB:       0,\n})\n\n// String\nrdb.Set(ctx, \"key\", \"value\", time.Hour).Err()\nval, _ := rdb.Get(ctx, \"key\").Result()\n\n// Hash\nrdb.HSet(ctx, \"user:1\", \"name\", \"Alice\", \"age\", 28)\nrdb.HGetAll(ctx, \"user:1\").Result()\n\n// List\nrdb.LPush(ctx, \"queue\", \"item1\", \"item2\")\nrdb.BRPop(ctx, 0, \"queue\").Result()\n\n// Set\nrdb.SAdd(ctx, \"tags\", \"golang\", \"redis\")\nrdb.SMembers(ctx, \"tags\").Result()\n\n// Sorted Set\nrdb.ZAdd(ctx, \"scores\", redis.Z{Score: 100, Member: \"player1\"})\nrdb.ZRevRangeWithScores(ctx, \"scores\", 0, 9).Result()\n\n// Pipeline\npipe := rdb.Pipeline()\npipe.Set(ctx, \"k1\", \"v1\", 0)\npipe.Set(ctx, \"k2\", \"v2\", 0)\npipe.Exec(ctx)\n</code></pre>\n<h2>缓存策略</h2>\n<h3>缓存模式</h3>\n<pre><code class=\"language-go\">// Cache Aside\nfunc GetUser(id string) (*User, error) {\n    // 1. 查缓存\n    cached, err := rdb.Get(ctx, \"user:\"+id).Result()\n    if err == nil {\n        return unmarshal(cached), nil\n    }\n\n    // 2. 查数据库\n    user, err := db.GetUser(id)\n    if err != nil {\n        return nil, err\n    }\n\n    // 3. 写缓存\n    rdb.Set(ctx, \"user:\"+id, marshal(user), time.Hour)\n    return user, nil\n}\n\n// Write Through\nfunc UpdateUser(user *User) error {\n    // 1. 更新数据库\n    if err := db.UpdateUser(user); err != nil {\n        return err\n    }\n\n    // 2. 更新缓存\n    return rdb.Set(ctx, \"user:\"+user.ID, marshal(user), time.Hour).Err()\n}\n</code></pre>\n<h3>缓存问题</h3>\n<pre><code class=\"language-go\">// 缓存穿透 - 查询不存在的数据\n// 解决: 布隆过滤器 / 空值缓存\nfunc GetWithBloomFilter(id string) (*User, error) {\n    if !bloomFilter.Contains(id) {\n        return nil, ErrNotFound\n    }\n    // 继续查询\n}\n\n// 缓存击穿 - 热点 key 过期\n// 解决: 互斥锁 / 逻辑过期\nfunc GetWithMutex(id string) (*User, error) {\n    // 获取锁\n    lockKey := \"lock:user:\" + id\n    if ok, _ := rdb.SetNX(ctx, lockKey, 1, time.Second*10).Result(); !ok {\n        time.Sleep(50 * time.Millisecond)\n        return GetWithMutex(id)\n    }\n    defer rdb.Del(ctx, lockKey)\n\n    // 查询并缓存\n    return fetchAndCache(id)\n}\n\n// 缓存雪崩 - 大量 key 同时过期\n// 解决: 过期时间加随机值\nfunc SetWithRandomExpire(key string, value interface{}) error {\n    expire := time.Hour + time.Duration(rand.Intn(300))*time.Second\n    return rdb.Set(ctx, key, value, expire).Err()\n}\n</code></pre>\n<h2>分布式锁</h2>\n<pre><code class=\"language-go\">// 加锁\nfunc Lock(key string, value string, expire time.Duration) bool {\n    return rdb.SetNX(ctx, key, value, expire).Val()\n}\n\n// 解锁 (Lua 脚本保证原子性)\nvar unlockScript = redis.NewScript(`\n    if redis.call(\"get\", KEYS[1]) == ARGV[1] then\n        return redis.call(\"del\", KEYS[1])\n    else\n        return 0\n    end\n`)\n\nfunc Unlock(key string, value string) bool {\n    result, _ := unlockScript.Run(ctx, rdb, []string{key}, value).Int()\n    return result == 1\n}\n\n// Redlock 算法 (多节点)\n// 1. 获取当前时间\n// 2. 依次向 N 个节点请求锁\n// 3. 大多数节点获取成功且未超时，则加锁成功\n// 4. 锁有效时间 = 初始有效时间 - 获取锁耗时\n</code></pre>\n<h2>持久化</h2>\n<pre><code class=\"language-yaml\"># RDB 快照\nsave 900 1      # 900秒内至少1次修改\nsave 300 10     # 300秒内至少10次修改\nsave 60 10000   # 60秒内至少10000次修改\n\n# AOF 日志\nappendonly yes\nappendfsync everysec  # 每秒同步\n\n# 混合持久化 (推荐)\naof-use-rdb-preamble yes\n</code></pre>\n<h2>集群</h2>\n<pre><code class=\"language-yaml\"># 主从复制\nslaveof 192.168.1.1 6379\n\n# 哨兵模式\nsentinel monitor mymaster 192.168.1.1 6379 2\nsentinel down-after-milliseconds mymaster 30000\nsentinel failover-timeout mymaster 180000\n\n# Cluster 模式\ncluster-enabled yes\ncluster-config-file nodes.conf\ncluster-node-timeout 15000\n</code></pre>\n<h2>总结</h2>\n<p>Redis 要点：</p>\n<ol>\n<li><strong>数据结构</strong> - String, Hash, List, Set, ZSet</li>\n<li><strong>缓存策略</strong> - Cache Aside, 穿透/击穿/雪崩</li>\n<li><strong>分布式锁</strong> - SETNX, Lua 脚本</li>\n<li><strong>持久化</strong> - RDB + AOF 混合</li>\n<li><strong>高可用</strong> - 主从, 哨兵, Cluster</li>\n</ol>\n"
}