{
  "slug": "indexing",
  "meta": {
    "title": "索引设计",
    "description": "数据库索引原理、设计策略与性能优化",
    "order": 2,
    "tags": [
      "database",
      "modeling",
      "indexing",
      "performance"
    ]
  },
  "content": "<h1>索引设计</h1>\n<h2>索引原理</h2>\n<p>索引是数据库中用于加速数据检索的数据结构，以额外存储空间换取查询性能。</p>\n<pre><code>索引数据结构\n├── B-Tree/B+Tree - 范围查询、排序\n├── Hash - 等值查询\n├── 全文索引 - 文本搜索\n├── 空间索引 - 地理位置\n└── 位图索引 - 低基数列\n</code></pre>\n<h2>B+Tree 索引</h2>\n<h3>结构特点</h3>\n<pre><code>B+Tree 特点\n├── 所有数据存储在叶子节点\n├── 叶子节点通过指针连接\n├── 非叶子节点只存储索引\n├── 高度平衡，查询复杂度 O(log n)\n└── 适合范围查询和排序\n\n聚簇索引 vs 非聚簇索引\n├── 聚簇索引: 数据按索引顺序存储\n│   └── InnoDB 主键索引\n└── 非聚簇索引: 索引与数据分离\n    └── 二级索引、MyISAM 索引\n</code></pre>\n<h3>索引类型</h3>\n<pre><code class=\"language-sql\">-- 主键索引 (聚簇)\nCREATE TABLE users (\n    id INT PRIMARY KEY,\n    email VARCHAR(100)\n);\n\n-- 唯一索引\nCREATE UNIQUE INDEX idx_email ON users(email);\n\n-- 普通索引\nCREATE INDEX idx_name ON users(name);\n\n-- 复合索引\nCREATE INDEX idx_name_age ON users(name, age);\n\n-- 前缀索引\nCREATE INDEX idx_email_prefix ON users(email(20));\n\n-- 降序索引\nCREATE INDEX idx_created_desc ON orders(created_at DESC);\n</code></pre>\n<h2>复合索引设计</h2>\n<h3>最左前缀原则</h3>\n<pre><code class=\"language-sql\">-- 索引: (a, b, c)\n-- 可以使用的查询\nWHERE a = 1                    -- 使用 a\nWHERE a = 1 AND b = 2          -- 使用 a, b\nWHERE a = 1 AND b = 2 AND c = 3 -- 使用 a, b, c\nWHERE a = 1 AND c = 3          -- 只使用 a\n\n-- 不能使用的查询\nWHERE b = 2                    -- 无法使用\nWHERE b = 2 AND c = 3          -- 无法使用\nWHERE c = 3                    -- 无法使用\n</code></pre>\n<h3>设计策略</h3>\n<pre><code class=\"language-sql\">-- 等值查询在前，范围查询在后\nCREATE INDEX idx_status_created ON orders(status, created_at);\n\n-- 高选择性列在前\n-- 假设 status 有 3 个值，user_id 有 100 万个值\nCREATE INDEX idx_user_status ON orders(user_id, status);\n\n-- 覆盖索引\n-- 查询的列都在索引中，避免回表\nCREATE INDEX idx_cover ON orders(user_id, status, created_at);\nSELECT user_id, status, created_at FROM orders WHERE user_id = 1;\n</code></pre>\n<h2>索引选择策略</h2>\n<h3>何时创建索引</h3>\n<pre><code class=\"language-yaml\">适合创建索引:\n  - WHERE 子句频繁使用的列\n  - JOIN 连接条件列\n  - ORDER BY 排序列\n  - GROUP BY 分组列\n  - 高选择性列 (唯一值多)\n\n不适合创建索引:\n  - 频繁更新的列\n  - 低选择性列 (如性别)\n  - 小表 (全表扫描更快)\n  - 很少查询的列\n</code></pre>\n<h3>索引评估</h3>\n<pre><code class=\"language-sql\">-- 查看索引使用情况\nEXPLAIN SELECT * FROM users WHERE email = 'test@example.com';\n\n-- 关键指标\n-- type: const > eq_ref > ref > range > index > ALL\n-- key: 使用的索引\n-- rows: 扫描行数\n-- Extra: Using index (覆盖索引)\n\n-- 强制使用索引\nSELECT * FROM users FORCE INDEX(idx_email) WHERE email = 'test@example.com';\n\n-- 索引统计\nSHOW INDEX FROM users;\n</code></pre>\n<h2>索引优化</h2>\n<h3>避免索引失效</h3>\n<pre><code class=\"language-sql\">-- 1. 避免在索引列上使用函数\n-- 失效\nSELECT * FROM users WHERE YEAR(created_at) = 2024;\n-- 优化\nSELECT * FROM users WHERE created_at >= '2024-01-01' AND created_at &#x3C; '2025-01-01';\n\n-- 2. 避免隐式类型转换\n-- 失效 (phone 是 VARCHAR)\nSELECT * FROM users WHERE phone = 13800138000;\n-- 优化\nSELECT * FROM users WHERE phone = '13800138000';\n\n-- 3. 避免使用 OR (考虑 UNION)\n-- 可能失效\nSELECT * FROM users WHERE name = 'Alice' OR age = 25;\n-- 优化\nSELECT * FROM users WHERE name = 'Alice'\nUNION\nSELECT * FROM users WHERE age = 25;\n\n-- 4. LIKE 前缀匹配\n-- 使用索引\nSELECT * FROM users WHERE name LIKE 'Ali%';\n-- 不使用索引\nSELECT * FROM users WHERE name LIKE '%ice';\n\n-- 5. NOT IN / NOT EXISTS\n-- 可能不使用索引\nSELECT * FROM users WHERE id NOT IN (1, 2, 3);\n</code></pre>\n<h3>索引维护</h3>\n<pre><code class=\"language-sql\">-- 重建索引\nALTER TABLE users ENGINE=InnoDB;\n\n-- 分析表 (更新统计信息)\nANALYZE TABLE users;\n\n-- 优化表 (整理碎片)\nOPTIMIZE TABLE users;\n\n-- 删除未使用的索引\nDROP INDEX idx_unused ON users;\n</code></pre>\n<h2>特殊索引</h2>\n<h3>全文索引</h3>\n<pre><code class=\"language-sql\">-- 创建全文索引\nCREATE FULLTEXT INDEX idx_content ON articles(title, content);\n\n-- 全文搜索\nSELECT * FROM articles\nWHERE MATCH(title, content) AGAINST('database optimization' IN NATURAL LANGUAGE MODE);\n\n-- 布尔模式\nSELECT * FROM articles\nWHERE MATCH(title, content) AGAINST('+database -mysql' IN BOOLEAN MODE);\n</code></pre>\n<h3>空间索引</h3>\n<pre><code class=\"language-sql\">-- 创建空间索引\nCREATE TABLE locations (\n    id INT PRIMARY KEY,\n    name VARCHAR(100),\n    position POINT NOT NULL,\n    SPATIAL INDEX(position)\n);\n\n-- 空间查询\nSELECT * FROM locations\nWHERE ST_Contains(\n    ST_GeomFromText('POLYGON((0 0, 10 0, 10 10, 0 10, 0 0))'),\n    position\n);\n</code></pre>\n<h2>索引监控</h2>\n<pre><code class=\"language-sql\">-- 查看索引使用统计 (MySQL 8.0+)\nSELECT * FROM sys.schema_index_statistics\nWHERE table_schema = 'mydb';\n\n-- 查看未使用的索引\nSELECT * FROM sys.schema_unused_indexes;\n\n-- 查看冗余索引\nSELECT * FROM sys.schema_redundant_indexes;\n</code></pre>\n<h2>总结</h2>\n<p>索引设计要点：</p>\n<ol>\n<li><strong>原理</strong> - B+Tree 结构，聚簇 vs 非聚簇</li>\n<li><strong>复合索引</strong> - 最左前缀，高选择性优先</li>\n<li><strong>覆盖索引</strong> - 避免回表，提升性能</li>\n<li><strong>避免失效</strong> - 函数、类型转换、LIKE</li>\n<li><strong>监控维护</strong> - 定期分析，清理冗余</li>\n</ol>\n"
}