{
  "slug": "sharding",
  "meta": {
    "title": "分库分表",
    "description": "数据库分片策略、分布式数据库架构与数据迁移",
    "order": 3,
    "tags": [
      "database",
      "modeling",
      "sharding",
      "distributed"
    ]
  },
  "content": "<h1>分库分表</h1>\n<h2>分库分表概述</h2>\n<p>当单库单表无法满足性能和存储需求时，需要通过分库分表进行水平扩展。</p>\n<pre><code>扩展方式\n├── 垂直拆分\n│   ├── 垂直分库 - 按业务拆分\n│   └── 垂直分表 - 按列拆分\n└── 水平拆分\n    ├── 水平分库 - 数据分散到多库\n    └── 水平分表 - 数据分散到多表\n</code></pre>\n<h2>垂直拆分</h2>\n<h3>垂直分库</h3>\n<pre><code>按业务领域拆分数据库\n\n原始: 单一数据库\n├── users\n├── orders\n├── products\n└── inventory\n\n拆分后:\n├── user_db\n│   └── users\n├── order_db\n│   └── orders\n└── product_db\n    ├── products\n    └── inventory\n</code></pre>\n<h3>垂直分表</h3>\n<pre><code class=\"language-sql\">-- 原始表 (宽表)\nCREATE TABLE products (\n    id INT PRIMARY KEY,\n    name VARCHAR(100),\n    price DECIMAL(10,2),\n    description TEXT,        -- 大字段\n    images JSON,             -- 大字段\n    specifications TEXT,     -- 大字段\n    stock INT,\n    created_at DATETIME\n);\n\n-- 拆分后\nCREATE TABLE products (\n    id INT PRIMARY KEY,\n    name VARCHAR(100),\n    price DECIMAL(10,2),\n    stock INT,\n    created_at DATETIME\n);\n\nCREATE TABLE product_details (\n    product_id INT PRIMARY KEY,\n    description TEXT,\n    images JSON,\n    specifications TEXT,\n    FOREIGN KEY (product_id) REFERENCES products(id)\n);\n</code></pre>\n<h2>水平拆分</h2>\n<h3>分片键选择</h3>\n<pre><code class=\"language-yaml\">分片键要求:\n  - 离散性高 - 数据均匀分布\n  - 查询频繁 - 避免跨分片查询\n  - 不常变更 - 避免数据迁移\n\n常用分片键:\n  - 用户 ID - 用户相关业务\n  - 订单 ID - 订单相关业务\n  - 时间 - 日志、历史数据\n  - 地区 - 地理位置相关\n</code></pre>\n<h3>分片策略</h3>\n<pre><code class=\"language-go\">// 1. 范围分片\n// 优点: 范围查询高效\n// 缺点: 可能数据倾斜\nfunc RangeShard(userID int) int {\n    if userID &#x3C; 1000000 {\n        return 0\n    } else if userID &#x3C; 2000000 {\n        return 1\n    }\n    return 2\n}\n\n// 2. 哈希分片\n// 优点: 数据均匀\n// 缺点: 范围查询需跨分片\nfunc HashShard(userID int, shardCount int) int {\n    return userID % shardCount\n}\n\n// 3. 一致性哈希\n// 优点: 扩容时迁移数据少\ntype ConsistentHash struct {\n    ring     map[uint32]int\n    replicas int\n}\n\nfunc (ch *ConsistentHash) GetShard(key string) int {\n    hash := crc32.ChecksumIEEE([]byte(key))\n    // 在环上找到顺时针最近的节点\n    for _, v := range ch.ring {\n        if hash &#x3C;= v {\n            return ch.ring[v]\n        }\n    }\n    return ch.ring[0]\n}\n\n// 4. 复合分片\n// 先按时间分库，再按用户哈希分表\nfunc CompositeShard(userID int, createTime time.Time) (db, table int) {\n    db = createTime.Year() - 2020  // 按年分库\n    table = userID % 64            // 64 张表\n    return db, table\n}\n</code></pre>\n<h2>分片中间件</h2>\n<h3>ShardingSphere</h3>\n<pre><code class=\"language-yaml\"># ShardingSphere 配置\ndataSources:\n  ds_0:\n    url: jdbc:mysql://localhost:3306/db0\n  ds_1:\n    url: jdbc:mysql://localhost:3306/db1\n\nrules:\n  - !SHARDING\n    tables:\n      orders:\n        actualDataNodes: ds_${0..1}.orders_${0..15}\n        tableStrategy:\n          standard:\n            shardingColumn: user_id\n            shardingAlgorithmName: order_table_hash\n        keyGenerateStrategy:\n          column: id\n          keyGeneratorName: snowflake\n\n    shardingAlgorithms:\n      order_table_hash:\n        type: HASH_MOD\n        props:\n          sharding-count: 16\n\n    keyGenerators:\n      snowflake:\n        type: SNOWFLAKE\n</code></pre>\n<h3>Vitess</h3>\n<pre><code class=\"language-yaml\"># Vitess VSchema\n{\n  \"sharded\": true,\n  \"vindexes\": {\n    \"hash\": {\n      \"type\": \"hash\"\n    }\n  },\n  \"tables\": {\n    \"orders\": {\n      \"column_vindexes\": [\n        {\n          \"column\": \"user_id\",\n          \"name\": \"hash\"\n        }\n      ]\n    }\n  }\n}\n</code></pre>\n<h2>分布式 ID</h2>\n<h3>Snowflake 算法</h3>\n<pre><code class=\"language-go\">// Snowflake ID 结构\n// 1 bit 符号位 | 41 bit 时间戳 | 10 bit 机器 ID | 12 bit 序列号\n\ntype Snowflake struct {\n    machineID     int64\n    sequence      int64\n    lastTimestamp int64\n}\n\nfunc (s *Snowflake) NextID() int64 {\n    timestamp := time.Now().UnixMilli()\n\n    if timestamp == s.lastTimestamp {\n        s.sequence = (s.sequence + 1) &#x26; 0xFFF\n        if s.sequence == 0 {\n            // 等待下一毫秒\n            for timestamp &#x3C;= s.lastTimestamp {\n                timestamp = time.Now().UnixMilli()\n            }\n        }\n    } else {\n        s.sequence = 0\n    }\n\n    s.lastTimestamp = timestamp\n\n    return ((timestamp - epoch) &#x3C;&#x3C; 22) |\n           (s.machineID &#x3C;&#x3C; 12) |\n           s.sequence\n}\n</code></pre>\n<h3>其他方案</h3>\n<pre><code class=\"language-yaml\">ID 生成方案:\n  - UUID: 无序，不适合索引\n  - 数据库自增: 有瓶颈\n  - Redis INCR: 性能好，需保证高可用\n  - Snowflake: 推荐，有序且分布式\n  - Leaf: 美团方案，双 buffer\n</code></pre>\n<h2>跨分片查询</h2>\n<h3>聚合查询</h3>\n<pre><code class=\"language-go\">// 并行查询所有分片\nfunc QueryAllShards(query string) ([]Result, error) {\n    var wg sync.WaitGroup\n    results := make([]Result, len(shards))\n\n    for i, shard := range shards {\n        wg.Add(1)\n        go func(i int, shard *DB) {\n            defer wg.Done()\n            results[i] = shard.Query(query)\n        }(i, shard)\n    }\n\n    wg.Wait()\n\n    // 合并结果\n    return mergeResults(results), nil\n}\n\n// 分页查询 (需要所有分片返回更多数据)\nfunc PaginationQuery(offset, limit int) []Result {\n    // 每个分片查询 offset + limit 条\n    allResults := QueryAllShards(offset + limit)\n\n    // 排序\n    sort.Slice(allResults, func(i, j int) bool {\n        return allResults[i].CreatedAt.After(allResults[j].CreatedAt)\n    })\n\n    // 取 offset 到 offset+limit\n    return allResults[offset : offset+limit]\n}\n</code></pre>\n<h3>分布式事务</h3>\n<pre><code class=\"language-yaml\">方案选择:\n  - 2PC: 强一致，性能差\n  - TCC: 业务侵入\n  - Saga: 最终一致\n  - 本地消息表: 可靠消息\n\n推荐:\n  - 尽量避免跨分片事务\n  - 使用最终一致性\n  - 业务层补偿\n</code></pre>\n<h2>数据迁移</h2>\n<pre><code class=\"language-yaml\">迁移步骤:\n  1. 双写: 新旧库同时写入\n  2. 历史数据迁移: 批量迁移历史数据\n  3. 数据校验: 验证数据一致性\n  4. 切读: 逐步切换读流量\n  5. 停写: 停止写旧库\n  6. 清理: 删除旧库\n\n注意事项:\n  - 增量同步\n  - 数据校验\n  - 回滚方案\n  - 灰度切换\n</code></pre>\n<h2>总结</h2>\n<p>分库分表要点：</p>\n<ol>\n<li><strong>拆分策略</strong> - 垂直按业务，水平按数据</li>\n<li><strong>分片键</strong> - 高离散性，查询频繁</li>\n<li><strong>分片算法</strong> - 哈希、范围、一致性哈希</li>\n<li><strong>分布式 ID</strong> - Snowflake 推荐</li>\n<li><strong>迁移</strong> - 双写、增量同步、灰度切换</li>\n</ol>\n"
}