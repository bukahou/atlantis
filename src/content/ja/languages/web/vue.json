{
  "meta": {
    "title": "Vue",
    "description": "Vue 3 Composition API とモダン開発実践",
    "order": 5,
    "tags": ["Vue", "Vue 3", "Composition API", "リアクティブ"]
  },
  "sections": [
    {
      "type": "keyPoints",
      "title": "コア概念",
      "items": [
        "Vue はプログレッシブ JavaScript フレームワーク",
        "リアクティブシステムで自動的に依存を追跡",
        "Composition API でより良いロジック再利用",
        "単一ファイルコンポーネント (SFC) でテンプレート/スクリプト/スタイルを統合"
      ]
    },
    {
      "type": "cards",
      "title": "Composition API",
      "layout": "grid",
      "columns": 3,
      "items": [
        {
          "title": "ref",
          "badge": "リアクティブ",
          "badgeColor": "blue",
          "points": [
            "プリミティブ型をラップ",
            ".value でアクセス",
            "テンプレートで自動アンラップ"
          ]
        },
        {
          "title": "reactive",
          "badge": "リアクティブ",
          "badgeColor": "green",
          "points": [
            "オブジェクト/配列をラップ",
            "深いリアクティブ",
            "プロパティ直接アクセス"
          ]
        },
        {
          "title": "computed",
          "badge": "算出",
          "badgeColor": "purple",
          "points": [
            "派生状態",
            "自動キャッシュ",
            "依存追跡"
          ]
        },
        {
          "title": "watch",
          "badge": "監視",
          "badgeColor": "amber",
          "points": [
            "リアクティブデータ監視",
            "副作用実行",
            "deep/immediate オプション"
          ]
        },
        {
          "title": "provide/inject",
          "badge": "依存注入",
          "badgeColor": "cyan",
          "points": [
            "階層越え値渡し",
            "Props ドリリング回避",
            "プラグイン/テーマ"
          ]
        },
        {
          "title": "ライフサイクル",
          "badge": "Hooks",
          "badgeColor": "red",
          "points": [
            "onMounted",
            "onUpdated",
            "onUnmounted"
          ]
        }
      ]
    },
    {
      "type": "codeBlock",
      "title": "Composition API 基礎",
      "language": "vue",
      "code": "<script setup lang=\"ts\">\nimport { ref, computed, onMounted } from 'vue';\n\ninterface User {\n  id: number;\n  name: string;\n}\n\n// Props\nconst props = defineProps<{\n  userId: number;\n}>();\n\n// Emits\nconst emit = defineEmits<{\n  (e: 'update', user: User): void;\n}>();\n\n// リアクティブ状態\nconst user = ref<User | null>(null);\nconst loading = ref(true);\n\n// 算出プロパティ\nconst displayName = computed(() => \n  user.value?.name ?? 'Unknown'\n);\n\n// ライフサイクル\nonMounted(async () => {\n  const res = await fetch(`/api/users/${props.userId}`);\n  user.value = await res.json();\n  loading.value = false;\n});\n\n// メソッド\nfunction handleUpdate() {\n  if (user.value) {\n    emit('update', user.value);\n  }\n}\n</script>\n\n<template>\n  <div v-if=\"loading\">Loading...</div>\n  <div v-else>\n    <h1>{{ displayName }}</h1>\n    <button @click=\"handleUpdate\">Update</button>\n  </div>\n</template>"
    },
    {
      "type": "codeBlock",
      "title": "Composables",
      "language": "ts",
      "code": "// composables/useFetch.ts\nimport { ref, watchEffect } from 'vue';\n\nexport function useFetch<T>(url: string | (() => string)) {\n  const data = ref<T | null>(null);\n  const loading = ref(true);\n  const error = ref<Error | null>(null);\n\n  async function doFetch(fetchUrl: string) {\n    loading.value = true;\n    error.value = null;\n    \n    try {\n      const res = await fetch(fetchUrl);\n      data.value = await res.json();\n    } catch (e) {\n      error.value = e as Error;\n    } finally {\n      loading.value = false;\n    }\n  }\n\n  watchEffect(() => {\n    const fetchUrl = typeof url === 'function' ? url() : url;\n    doFetch(fetchUrl);\n  });\n\n  return { data, loading, error };\n}\n\n// 使用\n// const { data: users, loading } = useFetch<User[]>('/api/users');"
    },
    {
      "type": "comparison",
      "title": "Options API vs Composition API",
      "columns": [
        {
          "title": "Options API",
          "color": "from-amber-500 to-orange-500",
          "items": [
            { "label": "構成", "description": "オプション別グループ (data/methods)" },
            { "label": "適用", "description": "シンプルなコンポーネント/入門" },
            { "label": "再利用", "description": "Mixins (名前衝突リスク)" }
          ]
        },
        {
          "title": "Composition API",
          "color": "from-green-500 to-emerald-500",
          "items": [
            { "label": "構成", "description": "論理的関心事別グループ" },
            { "label": "適用", "description": "複雑なコンポーネント/大規模" },
            { "label": "再利用", "description": "Composables (型安全)" }
          ]
        }
      ]
    },
    {
      "type": "codeBlock",
      "title": "Pinia 状態管理",
      "language": "ts",
      "code": "// stores/user.ts\nimport { defineStore } from 'pinia';\nimport { ref, computed } from 'vue';\n\nexport const useUserStore = defineStore('user', () => {\n  // State\n  const user = ref<User | null>(null);\n  const token = ref<string | null>(null);\n\n  // Getters\n  const isLoggedIn = computed(() => !!token.value);\n  const userName = computed(() => user.value?.name ?? 'Guest');\n\n  // Actions\n  async function login(email: string, password: string) {\n    const res = await fetch('/api/login', {\n      method: 'POST',\n      body: JSON.stringify({ email, password }),\n    });\n    const data = await res.json();\n    user.value = data.user;\n    token.value = data.token;\n  }\n\n  function logout() {\n    user.value = null;\n    token.value = null;\n  }\n\n  return { user, token, isLoggedIn, userName, login, logout };\n});\n\n// コンポーネントで使用\n// const userStore = useUserStore();\n// userStore.login(email, password);"
    },
    {
      "type": "table",
      "title": "Vue エコシステム",
      "highlightFirst": true,
      "headers": ["カテゴリ", "推奨", "用途"],
      "rows": [
        ["ルーティング", "Vue Router", "SPA ルーティング"],
        ["状態", "Pinia", "グローバル状態"],
        ["ビルド", "Vite", "開発/ビルド"],
        ["UI ライブラリ", "Element Plus / Naive UI", "コンポーネントライブラリ"],
        ["SSR", "Nuxt 3", "フルスタックフレームワーク"],
        ["テスト", "Vitest + Vue Test Utils", "ユニット/コンポーネントテスト"]
      ]
    },
    {
      "type": "list",
      "title": "ベストプラクティス",
      "style": "check",
      "items": [
        { "label": "<script setup> 使用", "description": "より簡潔な Composition API 構文" },
        { "label": "Composables 抽出", "description": "再利用ロジックを Composables に" },
        { "label": "ref vs reactive", "description": "プリミティブは ref、オブジェクトは reactive" },
        { "label": "分割代入回避", "description": "toRefs でリアクティブ性維持" },
        { "label": "Pinia で Vuex 代替", "description": "より良い TypeScript サポート" }
      ]
    }
  ],
  "relatedTopics": ["TypeScript", "Nuxt", "Pinia", "コンポーネント設計"]
}
