{
  "meta": {
    "title": "OAuth 2.0",
    "description": "認可コードフロー、PKCEとベストプラクティス",
    "order": 1,
    "tags": ["OAuth", "認証", "認可"]
  },
  "sections": [
    {
      "type": "keyPoints",
      "title": "コアコンセプト",
      "items": [
        "OAuth 2.0は認可フレームワークであり、認証プロトコルではない",
        "4つの認可モード：認可コード、インプリシット、パスワード、クライアントクレデンシャル",
        "PKCE：パブリッククライアントのセキュリティ強化",
        "Access Token + Refresh Token デュアルトークンメカニズム"
      ]
    },
    {
      "type": "cards",
      "title": "OAuth 2.0 ロール",
      "layout": "grid",
      "columns": 4,
      "items": [
        {
          "title": "リソースオーナー",
          "badge": "User",
          "badgeColor": "blue",
          "points": ["エンドユーザー", "アクセスを認可"]
        },
        {
          "title": "クライアント",
          "badge": "Client",
          "badgeColor": "green",
          "points": ["サードパーティアプリ", "認可を要求"]
        },
        {
          "title": "認可サーバー",
          "badge": "AuthZ",
          "badgeColor": "purple",
          "points": ["ID検証", "トークン発行"]
        },
        {
          "title": "リソースサーバー",
          "badge": "API",
          "badgeColor": "orange",
          "points": ["リソース保護", "トークン検証"]
        }
      ]
    },
    {
      "type": "codeBlock",
      "title": "認可コードフロー",
      "language": "text",
      "code": "     ┌──────────┐                              ┌──────────────┐\n     │  ユーザー │                              │  認可サーバー │\n     └────┬─────┘                              └───────┬──────┘\n          │                                            │\n          │  1. ログインクリック                        │\n          ▼                                            │\n     ┌──────────┐  2. 認可ページにリダイレクト          │\n     │ クライアント│─────────────────────────────────────►│\n     └────┬─────┘                                      │\n          │                                            │\n          │◄───────────────────────────────────────────│\n          │  3. ユーザー同意、authorization_code返却     │\n          │                                            │\n          │  4. codeでtokenを取得                       │\n          │─────────────────────────────────────────────►\n          │                                            │\n          │◄───────────────────────────────────────────│\n          │  5. access_token + refresh_token返却       │\n          │                                            │\n          │  6. access_tokenでリソースアクセス          │\n          │────────────────────────────────────────────►│\n     ┌────┴─────┐                              ┌───────┴──────┐\n     │リソースサーバー│◄─────────────────────────────│  リソースデータ │\n     └──────────┘                              └──────────────┘"
    },
    {
      "type": "codeBlock",
      "title": "認可コード + PKCE 実装",
      "language": "typescript",
      "code": "// 1. PKCEパラメータ生成\nfunction generatePKCE() {\n  // code_verifier: ランダム文字列\n  const codeVerifier = base64URLEncode(\n    crypto.getRandomValues(new Uint8Array(32))\n  );\n  \n  // code_challenge: SHA256(code_verifier)のbase64url\n  const codeChallenge = base64URLEncode(\n    await crypto.subtle.digest('SHA-256', \n      new TextEncoder().encode(codeVerifier)\n    )\n  );\n  \n  return { codeVerifier, codeChallenge };\n}\n\n// 2. 認可リクエスト開始\nconst { codeVerifier, codeChallenge } = generatePKCE();\nsessionStorage.setItem('code_verifier', codeVerifier);\n\nconst authUrl = new URL('https://auth.example.com/authorize');\nauthUrl.searchParams.set('response_type', 'code');\nauthUrl.searchParams.set('client_id', CLIENT_ID);\nauthUrl.searchParams.set('redirect_uri', REDIRECT_URI);\nauthUrl.searchParams.set('scope', 'openid profile email');\nauthUrl.searchParams.set('state', generateState()); // CSRF防止\nauthUrl.searchParams.set('code_challenge', codeChallenge);\nauthUrl.searchParams.set('code_challenge_method', 'S256');\n\nwindow.location.href = authUrl.toString();\n\n// 3. コールバック処理：codeでtokenを取得\nasync function handleCallback(code: string) {\n  const codeVerifier = sessionStorage.getItem('code_verifier');\n  \n  const response = await fetch('https://auth.example.com/token', {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },\n    body: new URLSearchParams({\n      grant_type: 'authorization_code',\n      code,\n      redirect_uri: REDIRECT_URI,\n      client_id: CLIENT_ID,\n      code_verifier: codeVerifier,  // PKCE検証\n    }),\n  });\n  \n  const { access_token, refresh_token } = await response.json();\n}"
    },
    {
      "type": "table",
      "title": "認可モード選択",
      "highlightFirst": true,
      "headers": ["モード", "適用場面", "セキュリティ", "説明"],
      "rows": [
        ["認可コード + PKCE", "SPA/モバイルアプリ", "高", "推奨方式"],
        ["認可コード", "サーバーサイドWebアプリ", "高", "バックエンドがある従来のWeb"],
        ["クライアントクレデンシャル", "サービス間通信", "中", "ユーザー関与なし"],
        ["デバイスコード", "スマートデバイス", "中", "ブラウザなしデバイス"],
        ["インプリシット", "非推奨", "低", "使用すべきでない"]
      ]
    },
    {
      "type": "list",
      "title": "セキュリティベストプラクティス",
      "style": "check",
      "items": [
        { "label": "常にHTTPS使用", "description": "すべてのOAuth通信は暗号化必須" },
        { "label": "stateパラメータ検証", "description": "CSRF攻撃を防止" },
        { "label": "PKCE使用", "description": "すべてのパブリッククライアントで必須" },
        { "label": "短期Access Token", "description": "Refresh Tokenと組み合わせて使用" },
        { "label": "Refresh Tokenローテーション", "description": "リフレッシュ毎に新しいRefresh Tokenを生成" }
      ]
    }
  ],
  "relatedTopics": ["OIDC", "JWT", "SSO"]
}
