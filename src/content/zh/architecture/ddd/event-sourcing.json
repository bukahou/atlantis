{
  "meta": {
    "title": "事件溯源",
    "description": "事件存储与状态重建",
    "order": 3,
    "tags": ["DDD", "事件溯源", "CQRS"]
  },
  "sections": [
    {
      "type": "keyPoints",
      "title": "核心概念",
      "items": [
        "事件溯源：用事件序列而非当前状态存储数据",
        "事件是不可变的事实记录",
        "通过重放事件重建聚合状态",
        "天然支持审计追踪和时间旅行"
      ]
    },
    {
      "type": "text",
      "title": "什么是事件溯源",
      "content": "传统方式只存储当前状态，丢失了变化历史。事件溯源则存储所有状态变化事件，当前状态通过重放事件计算得出。就像银行账户，与其只存余额，不如存储所有交易记录，余额可以随时计算。"
    },
    {
      "type": "comparison",
      "title": "传统存储 vs 事件溯源",
      "columns": [
        {
          "title": "传统存储",
          "color": "from-gray-500 to-slate-500",
          "items": [
            { "label": "存储", "description": "当前状态" },
            { "label": "更新", "description": "覆盖旧值" },
            { "label": "历史", "description": "需额外审计表" },
            { "label": "调试", "description": "难以追溯问题" }
          ]
        },
        {
          "title": "事件溯源",
          "color": "from-blue-500 to-cyan-500",
          "items": [
            { "label": "存储", "description": "事件序列" },
            { "label": "更新", "description": "追加事件" },
            { "label": "历史", "description": "天然完整审计" },
            { "label": "调试", "description": "可回放任意时刻" }
          ]
        }
      ]
    },
    {
      "type": "codeBlock",
      "title": "事件溯源聚合实现",
      "language": "typescript",
      "code": "// 领域事件\nabstract class DomainEvent {\n  readonly occurredAt: Date = new Date();\n  abstract readonly eventType: string;\n}\n\nclass AccountCreatedEvent extends DomainEvent {\n  readonly eventType = 'AccountCreated';\n  constructor(\n    public readonly accountId: string,\n    public readonly initialBalance: number\n  ) { super(); }\n}\n\nclass MoneyDepositedEvent extends DomainEvent {\n  readonly eventType = 'MoneyDeposited';\n  constructor(\n    public readonly accountId: string,\n    public readonly amount: number\n  ) { super(); }\n}\n\nclass MoneyWithdrawnEvent extends DomainEvent {\n  readonly eventType = 'MoneyWithdrawn';\n  constructor(\n    public readonly accountId: string,\n    public readonly amount: number\n  ) { super(); }\n}\n\n// 事件溯源聚合\nclass Account {\n  private id: string;\n  private balance: number = 0;\n  private changes: DomainEvent[] = [];\n  \n  // 从事件重建状态\n  static fromEvents(events: DomainEvent[]): Account {\n    const account = new Account();\n    events.forEach(e => account.apply(e));\n    return account;\n  }\n  \n  // 命令：存款\n  deposit(amount: number): void {\n    if (amount <= 0) throw new Error('Invalid amount');\n    this.applyChange(new MoneyDepositedEvent(this.id, amount));\n  }\n  \n  // 命令：取款\n  withdraw(amount: number): void {\n    if (amount > this.balance) throw new Error('Insufficient balance');\n    this.applyChange(new MoneyWithdrawnEvent(this.id, amount));\n  }\n  \n  // 应用事件（更新状态）\n  private apply(event: DomainEvent): void {\n    if (event instanceof AccountCreatedEvent) {\n      this.id = event.accountId;\n      this.balance = event.initialBalance;\n    } else if (event instanceof MoneyDepositedEvent) {\n      this.balance += event.amount;\n    } else if (event instanceof MoneyWithdrawnEvent) {\n      this.balance -= event.amount;\n    }\n  }\n  \n  // 记录变更\n  private applyChange(event: DomainEvent): void {\n    this.apply(event);\n    this.changes.push(event);\n  }\n  \n  getUncommittedChanges(): DomainEvent[] {\n    return [...this.changes];\n  }\n}"
    },
    {
      "type": "codeBlock",
      "title": "事件存储",
      "language": "typescript",
      "code": "// 事件存储接口\ninterface EventStore {\n  // 追加事件\n  append(\n    streamId: string,\n    events: DomainEvent[],\n    expectedVersion: number\n  ): Promise<void>;\n  \n  // 读取事件流\n  readStream(\n    streamId: string,\n    fromVersion?: number\n  ): Promise<DomainEvent[]>;\n}\n\n// 仓储实现\nclass AccountRepository {\n  constructor(private eventStore: EventStore) {}\n  \n  async findById(id: string): Promise<Account | null> {\n    const events = await this.eventStore.readStream(`account-${id}`);\n    if (events.length === 0) return null;\n    return Account.fromEvents(events);\n  }\n  \n  async save(account: Account): Promise<void> {\n    const changes = account.getUncommittedChanges();\n    if (changes.length === 0) return;\n    \n    await this.eventStore.append(\n      `account-${account.id}`,\n      changes,\n      account.version  // 乐观锁\n    );\n  }\n}\n\n// 快照优化（避免重放过多事件）\ninterface Snapshot {\n  version: number;\n  state: any;\n}\n\nasync function loadWithSnapshot(id: string): Promise<Account> {\n  const snapshot = await snapshotStore.get(id);\n  const events = await eventStore.readStream(\n    id,\n    snapshot?.version ?? 0\n  );\n  return Account.fromSnapshot(snapshot, events);\n}"
    },
    {
      "type": "table",
      "title": "适用场景",
      "highlightFirst": true,
      "headers": ["场景", "适合度", "原因"],
      "rows": [
        ["审计要求严格", "非常适合", "天然完整历史"],
        ["复杂业务逻辑", "适合", "事件驱动建模清晰"],
        ["需要时间旅行", "非常适合", "可重建任意时刻状态"],
        ["简单CRUD", "不适合", "过度设计"],
        ["频繁查询", "需配合CQRS", "重放开销大"]
      ]
    },
    {
      "type": "list",
      "title": "注意事项",
      "style": "check",
      "items": [
        { "label": "事件不可变", "description": "已发布的事件不能修改，只能通过新事件补偿" },
        { "label": "快照优化", "description": "定期创建快照避免重放过多事件" },
        { "label": "事件版本化", "description": "事件结构变化需要版本升级策略" },
        { "label": "配合CQRS", "description": "读模型通过投影优化查询性能" }
      ]
    }
  ],
  "relatedTopics": ["CQRS", "领域事件", "审计日志"]
}
