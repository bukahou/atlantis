{
  "meta": {
    "title": "虚拟机 vs 容器",
    "description": "虚拟化技术对比：Hypervisor、容器运行时与隔离机制",
    "order": 1,
    "tags": ["容器", "虚拟机", "Hypervisor", "Namespace", "cgroups"]
  },
  "sections": [
    {
      "type": "keyPoints",
      "title": "核心概念",
      "items": [
        "虚拟机通过 Hypervisor 实现硬件级虚拟化",
        "容器通过 Linux 内核特性实现进程级隔离",
        "VM 的 Guest OS 是完整操作系统 (内核+用户空间)",
        "容器镜像只包含用户空间，共享宿主机内核",
        "多容器通过 Namespace 隔离，通过 cgroups 限制资源"
      ]
    },
    {
      "type": "flow",
      "title": "虚拟机架构",
      "direction": "vertical",
      "steps": [
        { "label": "应用程序", "description": "App + Libs", "color": "bg-blue-500" },
        { "label": "Guest OS", "description": "完整操作系统", "color": "bg-cyan-500" },
        { "label": "Hypervisor", "description": "VMware/KVM/Hyper-V", "color": "bg-purple-500" },
        { "label": "Host OS", "description": "宿主机系统 (Type 2)", "color": "bg-orange-500" },
        { "label": "硬件", "description": "CPU/Memory/Storage", "color": "bg-gray-500" }
      ]
    },
    {
      "type": "flow",
      "title": "容器架构",
      "direction": "vertical",
      "steps": [
        { "label": "应用程序", "description": "App + Libs", "color": "bg-blue-500" },
        { "label": "容器运行时", "description": "containerd/CRI-O", "color": "bg-cyan-500" },
        { "label": "Linux 内核", "description": "Namespace + cgroups", "color": "bg-purple-500" },
        { "label": "Host OS", "description": "宿主机系统", "color": "bg-gray-500" }
      ]
    },
    {
      "type": "text",
      "title": "操作系统的本质区别",
      "content": "操作系统由两部分组成：内核空间 (Kernel Space) 和用户空间 (User Space)。内核负责硬件管理、进程调度、内存管理等底层操作；用户空间包含系统库、工具链、应用程序等。虚拟机的 Guest OS 包含完整的内核和用户空间，每个 VM 运行独立的内核实例。而容器镜像只包含用户空间（库、工具、配置文件），所有容器共享宿主机的同一个内核。这就是为什么容器镜像只有 MB 级而 VM 镜像是 GB 级的根本原因。"
    },
    {
      "type": "comparison",
      "title": "镜像 OS vs VM OS",
      "columns": [
        {
          "title": "VM Guest OS",
          "color": "from-purple-500 to-pink-500",
          "items": [
            { "label": "完整内核", "description": "独立的 Linux/Windows 内核实例" },
            { "label": "独立用户空间", "description": "完整的 /bin, /lib, /etc 等" },
            { "label": "独立启动流程", "description": "BIOS → Bootloader → Kernel → Init" },
            { "label": "资源开销", "description": "内核占用数百 MB 内存" }
          ]
        },
        {
          "title": "容器镜像",
          "color": "from-blue-500 to-cyan-500",
          "items": [
            { "label": "无内核", "description": "共享宿主机内核，不含自己的内核" },
            { "label": "仅用户空间", "description": "只包含应用运行所需的库和工具" },
            { "label": "进程启动", "description": "直接启动应用进程，无需引导" },
            { "label": "资源开销", "description": "仅应用本身的内存占用" }
          ]
        }
      ]
    },
    {
      "type": "codeBlock",
      "title": "容器共享内核的证明",
      "language": "bash",
      "code": "# 在宿主机上查看内核版本\nuname -r\n# 输出: 5.15.0-generic\n\n# 在容器内查看内核版本 (完全相同!)\ndocker run --rm alpine uname -r\n# 输出: 5.15.0-generic  ← 和宿主机一样\n\n# 容器内的进程在宿主机上可见\ndocker run -d --name test nginx\ndocker top test\n# 或者在宿主机直接 ps aux | grep nginx\n\n# 容器本质上就是宿主机上的进程\nps aux | grep 'nginx: master'"
    },
    {
      "type": "text",
      "title": "多容器共存原理",
      "content": "多个容器能在同一台机器上共存且相互隔离，核心依赖 Linux 内核的两个特性：Namespace 提供隔离视图，让每个容器「看起来」像独立的系统；cgroups 提供资源限制，防止单个容器耗尽主机资源。每个容器拥有独立的进程树（PID Namespace）、网络栈（NET Namespace）、文件系统视图（MNT Namespace），但它们的进程实际上都运行在同一个内核上，共享内核的调度器、内存管理器等核心组件。"
    },
    {
      "type": "flow",
      "title": "多容器隔离架构",
      "direction": "vertical",
      "steps": [
        { "label": "Container A", "description": "PID NS: 1,2,3 | NET NS: 172.17.0.2 | MNT NS: /app-a", "color": "bg-blue-500" },
        { "label": "Container B", "description": "PID NS: 1,2 | NET NS: 172.17.0.3 | MNT NS: /app-b", "color": "bg-cyan-500" },
        { "label": "Container C", "description": "PID NS: 1 | NET NS: 172.17.0.4 | MNT NS: /app-c", "color": "bg-green-500" },
        { "label": "宿主机内核", "description": "统一调度所有容器进程 (实际 PID: 1000-3000)", "color": "bg-purple-500" },
        { "label": "硬件资源", "description": "CPU / Memory / Disk / Network", "color": "bg-gray-500" }
      ]
    },
    {
      "type": "codeBlock",
      "title": "多容器隔离演示",
      "language": "bash",
      "code": "# 启动两个容器\ndocker run -d --name app1 nginx\ndocker run -d --name app2 nginx\n\n# 容器内看到的 PID 都是 1 (各自的 PID Namespace)\ndocker exec app1 ps aux | head -2\n# PID 1: nginx master process\n\ndocker exec app2 ps aux | head -2  \n# PID 1: nginx master process (另一个 Namespace，互不干扰)\n\n# 但在宿主机上，它们是不同的 PID\nps aux | grep 'nginx: master'\n# PID 12345: nginx (app1)\n# PID 12567: nginx (app2)\n\n# 网络也是隔离的，各有独立 IP\ndocker inspect app1 --format '{{.NetworkSettings.IPAddress}}'\n# 172.17.0.2\ndocker inspect app2 --format '{{.NetworkSettings.IPAddress}}'\n# 172.17.0.3"
    },
    {
      "type": "cards",
      "title": "Hypervisor 类型",
      "layout": "grid",
      "columns": 2,
      "items": [
        {
          "title": "Type 1 (裸金属)",
          "badge": "企业级",
          "badgeColor": "blue",
          "points": [
            "直接运行在硬件上",
            "VMware ESXi",
            "Microsoft Hyper-V",
            "KVM (Linux 内置)",
            "性能好，生产环境首选"
          ]
        },
        {
          "title": "Type 2 (托管型)",
          "badge": "桌面",
          "badgeColor": "green",
          "points": [
            "运行在宿主 OS 之上",
            "VMware Workstation",
            "VirtualBox",
            "Parallels Desktop",
            "开发测试环境常用"
          ]
        }
      ]
    },
    {
      "type": "cards",
      "title": "Linux 容器核心技术",
      "layout": "grid",
      "columns": 2,
      "items": [
        {
          "title": "Namespace (命名空间)",
          "badge": "隔离",
          "badgeColor": "blue",
          "points": [
            "PID: 进程 ID 隔离，容器内 PID 从 1 开始",
            "NET: 独立网络栈、IP、端口",
            "MNT: 独立文件系统挂载点",
            "UTS: 独立主机名和域名",
            "IPC: 独立进程间通信",
            "USER: 用户 ID 映射隔离"
          ]
        },
        {
          "title": "cgroups (控制组)",
          "badge": "限制",
          "badgeColor": "green",
          "points": [
            "cpu: 限制 CPU 时间片",
            "memory: 限制内存用量 (OOM)",
            "blkio: 限制块设备 I/O",
            "cpuset: 绑定 CPU 核心",
            "devices: 控制设备访问",
            "freezer: 暂停/恢复进程组"
          ]
        }
      ]
    },
    {
      "type": "codeBlock",
      "title": "Namespace 演示",
      "language": "bash",
      "code": "# 查看当前进程的 Namespace\nls -la /proc/$$/ns/\n\n# 创建新的 PID Namespace 并运行 shell\nsudo unshare --pid --fork --mount-proc /bin/bash\nps aux  # 只能看到当前 Namespace 的进程\n\n# 创建新的 NET Namespace\nsudo ip netns add test-ns\nsudo ip netns exec test-ns ip addr  # 独立的网络栈\n\n# 查看容器的 Namespace\ndocker inspect --format '{{.State.Pid}}' <container>\nls -la /proc/<pid>/ns/"
    },
    {
      "type": "codeBlock",
      "title": "cgroups 演示",
      "language": "bash",
      "code": "# 查看 cgroup 挂载点\nmount | grep cgroup\n\n# 查看容器的 cgroup 限制\ncat /sys/fs/cgroup/memory/docker/<container-id>/memory.limit_in_bytes\ncat /sys/fs/cgroup/cpu/docker/<container-id>/cpu.cfs_quota_us\n\n# 手动创建 cgroup 限制内存\nsudo mkdir /sys/fs/cgroup/memory/test-cgroup\necho 100000000 > /sys/fs/cgroup/memory/test-cgroup/memory.limit_in_bytes  # 100MB\necho $$ > /sys/fs/cgroup/memory/test-cgroup/cgroup.procs  # 将当前进程加入"
    },
    {
      "type": "table",
      "title": "详细对比",
      "highlightFirst": true,
      "headers": ["特性", "虚拟机", "容器"],
      "rows": [
        ["启动时间", "分钟级", "秒级/毫秒级"],
        ["镜像大小", "GB 级 (含完整 OS)", "MB 级 (仅应用+依赖)"],
        ["资源开销", "高 (每 VM 独立内核)", "低 (共享宿主内核)"],
        ["隔离级别", "硬件级 (强隔离)", "进程级 (内核共享)"],
        ["安全性", "高 (独立内核)", "相对较低 (内核漏洞风险)"],
        ["密度", "单机数十个", "单机数百/数千个"],
        ["迁移", "整机迁移", "镜像迁移"],
        ["典型用途", "异构 OS、强隔离", "微服务、CI/CD、云原生"]
      ]
    },
    {
      "type": "cards",
      "title": "容器运行时",
      "layout": "grid",
      "columns": 3,
      "items": [
        {
          "title": "containerd",
          "badge": "主流",
          "badgeColor": "blue",
          "points": [
            "Docker 拆分出的运行时",
            "K8s 默认运行时",
            "CNCF 毕业项目"
          ]
        },
        {
          "title": "CRI-O",
          "badge": "轻量",
          "badgeColor": "green",
          "points": [
            "专为 K8s 设计",
            "Red Hat 主导",
            "最小化实现"
          ]
        },
        {
          "title": "runc",
          "badge": "底层",
          "badgeColor": "gray",
          "points": [
            "OCI 参考实现",
            "实际创建容器",
            "被上层运行时调用"
          ]
        }
      ]
    },
    {
      "type": "comparison",
      "title": "何时选择",
      "columns": [
        {
          "title": "选择虚拟机",
          "color": "from-purple-500 to-pink-500",
          "items": [
            { "label": "异构 OS", "description": "需要运行 Windows/不同 Linux 发行版" },
            { "label": "强隔离", "description": "多租户、安全敏感场景" },
            { "label": "遗留系统", "description": "无法容器化的老应用" },
            { "label": "完整环境", "description": "需要完整系统环境模拟" }
          ]
        },
        {
          "title": "选择容器",
          "color": "from-blue-500 to-cyan-500",
          "items": [
            { "label": "微服务", "description": "快速部署、弹性伸缩" },
            { "label": "CI/CD", "description": "构建环境一致性" },
            { "label": "高密度", "description": "单机运行大量服务" },
            { "label": "云原生", "description": "K8s 生态、DevOps" }
          ]
        }
      ]
    },
    {
      "type": "list",
      "title": "最佳实践",
      "style": "check",
      "items": [
        { "label": "安全敏感用 VM", "description": "多租户隔离优先考虑虚拟机" },
        { "label": "微服务用容器", "description": "快速迭代、弹性伸缩场景" },
        { "label": "混合部署", "description": "VM 内运行容器，兼顾隔离和效率" },
        { "label": "加固容器安全", "description": "使用 gVisor/Kata Containers 增强隔离" }
      ]
    }
  ],
  "relatedTopics": ["容器镜像", "Docker", "Kubernetes", "Linux 内核"]
}
